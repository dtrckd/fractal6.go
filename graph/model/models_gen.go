// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
)

type AddBlobInput struct {
	CreatedAt  string           `json:"createdAt,omitempty"`
	UpdatedAt  *string          `json:"updatedAt,omitempty"`
	CreatedBy  *UserRef         `json:"createdBy,omitempty"`
	Message    *string          `json:"message,omitempty"`
	Tension    *TensionRef      `json:"tension,omitempty"`
	BlobType   BlobType         `json:"blob_type,omitempty"`
	PushedFlag *string          `json:"pushedFlag,omitempty"`
	Node       *NodeFragmentRef `json:"node,omitempty"`
	Md         *string          `json:"md,omitempty"`
}

type AddBlobPayload struct {
	Blob    []*Blob `json:"blob,omitempty"`
	NumUids *int    `json:"numUids,omitempty"`
}

type AddCommentInput struct {
	CreatedAt string   `json:"createdAt,omitempty"`
	UpdatedAt *string  `json:"updatedAt,omitempty"`
	CreatedBy *UserRef `json:"createdBy,omitempty"`
	Message   *string  `json:"message,omitempty"`
	Void      *string  `json:"_VOID,omitempty"`
}

type AddCommentPayload struct {
	Comment []*Comment `json:"comment,omitempty"`
	NumUids *int       `json:"numUids,omitempty"`
}

type AddEventInput struct {
	CreatedAt string       `json:"createdAt,omitempty"`
	UpdatedAt *string      `json:"updatedAt,omitempty"`
	CreatedBy *UserRef     `json:"createdBy,omitempty"`
	Message   *string      `json:"message,omitempty"`
	EventType TensionEvent `json:"event_type,omitempty"`
	Old       *string      `json:"old,omitempty"`
	New       *string      `json:"new,omitempty"`
}

type AddEventPayload struct {
	Event   []*Event `json:"event,omitempty"`
	NumUids *int     `json:"numUids,omitempty"`
}

type AddLabelInput struct {
	Name  string  `json:"name,omitempty"`
	Color *string `json:"color,omitempty"`
}

type AddLabelPayload struct {
	Label   []*Label `json:"label,omitempty"`
	NumUids *int     `json:"numUids,omitempty"`
}

type AddMandateInput struct {
	Purpose          string  `json:"purpose,omitempty"`
	Responsabilities *string `json:"responsabilities,omitempty"`
	Domains          *string `json:"domains,omitempty"`
	Policies         *string `json:"policies,omitempty"`
}

type AddMandatePayload struct {
	Mandate []*Mandate `json:"mandate,omitempty"`
	NumUids *int       `json:"numUids,omitempty"`
}

type AddNodeCharacInput struct {
	UserCanJoin bool     `json:"userCanJoin"`
	Mode        NodeMode `json:"mode,omitempty"`
}

type AddNodeCharacPayload struct {
	NodeCharac []*NodeCharac `json:"nodeCharac,omitempty"`
	NumUids    *int          `json:"numUids,omitempty"`
}

type AddNodeFragmentInput struct {
	Name       *string            `json:"name,omitempty"`
	Nameid     *string            `json:"nameid,omitempty"`
	Type       *NodeType          `json:"type_,omitempty"`
	IsPrivate  *bool              `json:"isPrivate"`
	Charac     *NodeCharacRef     `json:"charac,omitempty"`
	About      *string            `json:"about,omitempty"`
	Mandate    *MandateRef        `json:"mandate,omitempty"`
	Children   []*NodeFragmentRef `json:"children,omitempty"`
	FirstLink  *string            `json:"first_link,omitempty"`
	SecondLink *string            `json:"second_link,omitempty"`
	Skills     []string           `json:"skills,omitempty"`
	RoleType   *RoleType          `json:"role_type,omitempty"`
}

type AddNodeFragmentPayload struct {
	NodeFragment []*NodeFragment `json:"nodeFragment,omitempty"`
	NumUids      *int            `json:"numUids,omitempty"`
}

type AddNodeInput struct {
	CreatedAt    string         `json:"createdAt,omitempty"`
	CreatedBy    *UserRef       `json:"createdBy,omitempty"`
	Name         string         `json:"name,omitempty"`
	Nameid       string         `json:"nameid,omitempty"`
	Rootnameid   string         `json:"rootnameid,omitempty"`
	Parent       *NodeRef       `json:"parent,omitempty"`
	Children     []*NodeRef     `json:"children,omitempty"`
	Type         NodeType       `json:"type_,omitempty"`
	TensionsOut  []*TensionRef  `json:"tensions_out,omitempty"`
	TensionsIn   []*TensionRef  `json:"tensions_in,omitempty"`
	About        *string        `json:"about,omitempty"`
	Mandate      *MandateRef    `json:"mandate,omitempty"`
	Docs         []*TensionRef  `json:"docs,omitempty"`
	Source       *TensionRef    `json:"source,omitempty"`
	NTensionsOut *int           `json:"n_tensions_out,omitempty"`
	NTensionsIn  *int           `json:"n_tensions_in,omitempty"`
	NChildren    *int           `json:"n_children,omitempty"`
	Stats        *NodeStatsRef  `json:"stats,omitempty"`
	IsRoot       bool           `json:"isRoot"`
	IsPrivate    bool           `json:"isPrivate"`
	Charac       *NodeCharacRef `json:"charac,omitempty"`
	FirstLink    *UserRef       `json:"first_link,omitempty"`
	SecondLink   *UserRef       `json:"second_link,omitempty"`
	Skills       []string       `json:"skills,omitempty"`
	RoleType     *RoleType      `json:"role_type,omitempty"`
}

type AddNodePayload struct {
	Node    []*Node `json:"node,omitempty"`
	NumUids *int    `json:"numUids,omitempty"`
}

type AddNodeStatsInput struct {
	NMember *int `json:"n_member,omitempty"`
	NGuest  *int `json:"n_guest,omitempty"`
	NCircle *int `json:"n_circle,omitempty"`
	NRole   *int `json:"n_role,omitempty"`
}

type AddNodeStatsPayload struct {
	NodeStats []*NodeStats `json:"nodeStats,omitempty"`
	NumUids   *int         `json:"numUids,omitempty"`
}

type AddTensionInput struct {
	CreatedAt  string         `json:"createdAt,omitempty"`
	UpdatedAt  *string        `json:"updatedAt,omitempty"`
	CreatedBy  *UserRef       `json:"createdBy,omitempty"`
	Message    *string        `json:"message,omitempty"`
	Nth        *string        `json:"nth,omitempty"`
	Title      string         `json:"title,omitempty"`
	Type       TensionType    `json:"type_,omitempty"`
	Emitter    *NodeRef       `json:"emitter,omitempty"`
	Emitterid  string         `json:"emitterid,omitempty"`
	Receiver   *NodeRef       `json:"receiver,omitempty"`
	Receiverid string         `json:"receiverid,omitempty"`
	Status     TensionStatus  `json:"status,omitempty"`
	Action     *TensionAction `json:"action,omitempty"`
	Labels     []*LabelRef    `json:"labels,omitempty"`
	Comments   []*CommentRef  `json:"comments,omitempty"`
	Blobs      []*BlobRef     `json:"blobs,omitempty"`
	History    []*EventRef    `json:"history,omitempty"`
	NComments  *int           `json:"n_comments,omitempty"`
	NBlobs     *int           `json:"n_blobs,omitempty"`
}

type AddTensionPayload struct {
	Tension []*Tension `json:"tension,omitempty"`
	NumUids *int       `json:"numUids,omitempty"`
}

type AddUserInput struct {
	CreatedAt      string         `json:"createdAt,omitempty"`
	Username       string         `json:"username,omitempty"`
	Name           *string        `json:"name,omitempty"`
	Password       string         `json:"password,omitempty"`
	Email          string         `json:"email,omitempty"`
	EmailHash      *string        `json:"emailHash,omitempty"`
	EmailValidated bool           `json:"emailValidated"`
	Rights         *UserRightsRef `json:"rights,omitempty"`
	Roles          []*NodeRef     `json:"roles,omitempty"`
	BackedRoles    []*NodeRef     `json:"backed_roles,omitempty"`
	Bio            *string        `json:"bio,omitempty"`
	Utc            *string        `json:"utc,omitempty"`
}

type AddUserPayload struct {
	User    []*User `json:"user,omitempty"`
	NumUids *int    `json:"numUids,omitempty"`
}

type AddUserRightsInput struct {
	CanLogin      bool `json:"canLogin"`
	CanCreateRoot bool `json:"canCreateRoot"`
}

type AddUserRightsPayload struct {
	UserRights []*UserRights `json:"userRights,omitempty"`
	NumUids    *int          `json:"numUids,omitempty"`
}

type AuthRule struct {
	And  []*AuthRule `json:"and,omitempty"`
	Or   []*AuthRule `json:"or,omitempty"`
	Not  *AuthRule   `json:"not,omitempty"`
	Rule *string     `json:"rule,omitempty"`
}

type Blob struct {
	Tension    *Tension      `json:"tension,omitempty"`
	BlobType   BlobType      `json:"blob_type,omitempty"`
	PushedFlag *string       `json:"pushedFlag,omitempty"`
	Node       *NodeFragment `json:"node,omitempty"`
	Md         *string       `json:"md,omitempty"`
	ID         string        `json:"id,omitempty"`
	CreatedAt  string        `json:"createdAt,omitempty"`
	UpdatedAt  *string       `json:"updatedAt,omitempty"`
	CreatedBy  *User         `json:"createdBy,omitempty"`
	Message    *string       `json:"message,omitempty"`
}

type BlobFilter struct {
	ID         []string              `json:"id,omitempty"`
	CreatedAt  *DateTimeFilter       `json:"createdAt,omitempty"`
	Message    *StringFullTextFilter `json:"message,omitempty"`
	BlobType   *BlobTypeHash         `json:"blob_type,omitempty"`
	PushedFlag *DateTimeFilter       `json:"pushedFlag,omitempty"`
	And        *BlobFilter           `json:"and,omitempty"`
	Or         *BlobFilter           `json:"or,omitempty"`
	Not        *BlobFilter           `json:"not,omitempty"`
}

type BlobOrder struct {
	Asc  *BlobOrderable `json:"asc,omitempty"`
	Desc *BlobOrderable `json:"desc,omitempty"`
	Then *BlobOrder     `json:"then,omitempty"`
}

type BlobPatch struct {
	CreatedAt  *string          `json:"createdAt,omitempty"`
	UpdatedAt  *string          `json:"updatedAt,omitempty"`
	CreatedBy  *UserRef         `json:"createdBy,omitempty"`
	Message    *string          `json:"message,omitempty"`
	Tension    *TensionRef      `json:"tension,omitempty"`
	BlobType   *BlobType        `json:"blob_type,omitempty"`
	PushedFlag *string          `json:"pushedFlag,omitempty"`
	Node       *NodeFragmentRef `json:"node,omitempty"`
	Md         *string          `json:"md,omitempty"`
}

type BlobRef struct {
	ID         *string          `json:"id,omitempty"`
	CreatedAt  *string          `json:"createdAt,omitempty"`
	UpdatedAt  *string          `json:"updatedAt,omitempty"`
	CreatedBy  *UserRef         `json:"createdBy,omitempty"`
	Message    *string          `json:"message,omitempty"`
	Tension    *TensionRef      `json:"tension,omitempty"`
	BlobType   *BlobType        `json:"blob_type,omitempty"`
	PushedFlag *string          `json:"pushedFlag,omitempty"`
	Node       *NodeFragmentRef `json:"node,omitempty"`
	Md         *string          `json:"md,omitempty"`
}

type BlobTypeHash struct {
	Eq BlobType `json:"eq,omitempty"`
}

type Comment struct {
	Message   string  `json:"message,omitempty"`
	ID        string  `json:"id,omitempty"`
	CreatedAt string  `json:"createdAt,omitempty"`
	UpdatedAt *string `json:"updatedAt,omitempty"`
	CreatedBy *User   `json:"createdBy,omitempty"`
}

type CommentFilter struct {
	ID        []string              `json:"id,omitempty"`
	CreatedAt *DateTimeFilter       `json:"createdAt,omitempty"`
	Message   *StringFullTextFilter `json:"message,omitempty"`
	And       *CommentFilter        `json:"and,omitempty"`
	Or        *CommentFilter        `json:"or,omitempty"`
	Not       *CommentFilter        `json:"not,omitempty"`
}

type CommentOrder struct {
	Asc  *CommentOrderable `json:"asc,omitempty"`
	Desc *CommentOrderable `json:"desc,omitempty"`
	Then *CommentOrder     `json:"then,omitempty"`
}

type CommentPatch struct {
	CreatedAt *string  `json:"createdAt,omitempty"`
	UpdatedAt *string  `json:"updatedAt,omitempty"`
	CreatedBy *UserRef `json:"createdBy,omitempty"`
	Message   *string  `json:"message,omitempty"`
	Void      *string  `json:"_VOID,omitempty"`
}

type CommentRef struct {
	ID        *string  `json:"id,omitempty"`
	CreatedAt *string  `json:"createdAt,omitempty"`
	UpdatedAt *string  `json:"updatedAt,omitempty"`
	CreatedBy *UserRef `json:"createdBy,omitempty"`
	Message   *string  `json:"message,omitempty"`
	Void      *string  `json:"_VOID,omitempty"`
}

type CustomHTTP struct {
	URL               string     `json:"url,omitempty"`
	Method            HTTPMethod `json:"method,omitempty"`
	Body              *string    `json:"body,omitempty"`
	Graphql           *string    `json:"graphql,omitempty"`
	Mode              *Mode      `json:"mode,omitempty"`
	ForwardHeaders    []string   `json:"forwardHeaders,omitempty"`
	SecretHeaders     []string   `json:"secretHeaders,omitempty"`
	SkipIntrospection *bool      `json:"skipIntrospection"`
}

type DateTimeFilter struct {
	Eq *string `json:"eq,omitempty"`
	Le *string `json:"le,omitempty"`
	Lt *string `json:"lt,omitempty"`
	Ge *string `json:"ge,omitempty"`
	Gt *string `json:"gt,omitempty"`
}

type DeleteBlobPayload struct {
	Msg     *string `json:"msg,omitempty"`
	NumUids *int    `json:"numUids,omitempty"`
}

type DeleteCommentPayload struct {
	Msg     *string `json:"msg,omitempty"`
	NumUids *int    `json:"numUids,omitempty"`
}

type DeleteEventPayload struct {
	Msg     *string `json:"msg,omitempty"`
	NumUids *int    `json:"numUids,omitempty"`
}

type DeleteLabelPayload struct {
	Msg     *string `json:"msg,omitempty"`
	NumUids *int    `json:"numUids,omitempty"`
}

type DeleteMandatePayload struct {
	Msg     *string `json:"msg,omitempty"`
	NumUids *int    `json:"numUids,omitempty"`
}

type DeleteNodeCharacPayload struct {
	Msg     *string `json:"msg,omitempty"`
	NumUids *int    `json:"numUids,omitempty"`
}

type DeleteNodeFragmentPayload struct {
	Msg     *string `json:"msg,omitempty"`
	NumUids *int    `json:"numUids,omitempty"`
}

type DeleteNodePayload struct {
	Msg     *string `json:"msg,omitempty"`
	NumUids *int    `json:"numUids,omitempty"`
}

type DeletePostPayload struct {
	Msg     *string `json:"msg,omitempty"`
	NumUids *int    `json:"numUids,omitempty"`
}

type DeleteTensionPayload struct {
	Msg     *string `json:"msg,omitempty"`
	NumUids *int    `json:"numUids,omitempty"`
}

type DeleteUserPayload struct {
	Msg     *string `json:"msg,omitempty"`
	NumUids *int    `json:"numUids,omitempty"`
}

type Event struct {
	EventType TensionEvent `json:"event_type,omitempty"`
	Old       *string      `json:"old,omitempty"`
	New       *string      `json:"new,omitempty"`
	ID        string       `json:"id,omitempty"`
	CreatedAt string       `json:"createdAt,omitempty"`
	UpdatedAt *string      `json:"updatedAt,omitempty"`
	CreatedBy *User        `json:"createdBy,omitempty"`
	Message   *string      `json:"message,omitempty"`
}

type EventFilter struct {
	ID        []string              `json:"id,omitempty"`
	CreatedAt *DateTimeFilter       `json:"createdAt,omitempty"`
	Message   *StringFullTextFilter `json:"message,omitempty"`
	EventType *TensionEventHash     `json:"event_type,omitempty"`
	And       *EventFilter          `json:"and,omitempty"`
	Or        *EventFilter          `json:"or,omitempty"`
	Not       *EventFilter          `json:"not,omitempty"`
}

type EventOrder struct {
	Asc  *EventOrderable `json:"asc,omitempty"`
	Desc *EventOrderable `json:"desc,omitempty"`
	Then *EventOrder     `json:"then,omitempty"`
}

type EventPatch struct {
	CreatedAt *string       `json:"createdAt,omitempty"`
	UpdatedAt *string       `json:"updatedAt,omitempty"`
	CreatedBy *UserRef      `json:"createdBy,omitempty"`
	Message   *string       `json:"message,omitempty"`
	EventType *TensionEvent `json:"event_type,omitempty"`
	Old       *string       `json:"old,omitempty"`
	New       *string       `json:"new,omitempty"`
}

type EventRef struct {
	ID        *string       `json:"id,omitempty"`
	CreatedAt *string       `json:"createdAt,omitempty"`
	UpdatedAt *string       `json:"updatedAt,omitempty"`
	CreatedBy *UserRef      `json:"createdBy,omitempty"`
	Message   *string       `json:"message,omitempty"`
	EventType *TensionEvent `json:"event_type,omitempty"`
	Old       *string       `json:"old,omitempty"`
	New       *string       `json:"new,omitempty"`
}

type FloatFilter struct {
	Eq *float64 `json:"eq,omitempty"`
	Le *float64 `json:"le,omitempty"`
	Lt *float64 `json:"lt,omitempty"`
	Ge *float64 `json:"ge,omitempty"`
	Gt *float64 `json:"gt,omitempty"`
}

type IntFilter struct {
	Eq *int `json:"eq,omitempty"`
	Le *int `json:"le,omitempty"`
	Lt *int `json:"lt,omitempty"`
	Ge *int `json:"ge,omitempty"`
	Gt *int `json:"gt,omitempty"`
}

type Label struct {
	ID    string  `json:"id,omitempty"`
	Name  string  `json:"name,omitempty"`
	Color *string `json:"color,omitempty"`
}

type LabelFilter struct {
	ID   []string          `json:"id,omitempty"`
	Name *StringHashFilter `json:"name,omitempty"`
	And  *LabelFilter      `json:"and,omitempty"`
	Or   *LabelFilter      `json:"or,omitempty"`
	Not  *LabelFilter      `json:"not,omitempty"`
}

type LabelOrder struct {
	Asc  *LabelOrderable `json:"asc,omitempty"`
	Desc *LabelOrderable `json:"desc,omitempty"`
	Then *LabelOrder     `json:"then,omitempty"`
}

type LabelPatch struct {
	Color *string `json:"color,omitempty"`
}

type LabelRef struct {
	ID    *string `json:"id,omitempty"`
	Name  *string `json:"name,omitempty"`
	Color *string `json:"color,omitempty"`
}

type Mandate struct {
	ID               string  `json:"id,omitempty"`
	Purpose          string  `json:"purpose,omitempty"`
	Responsabilities *string `json:"responsabilities,omitempty"`
	Domains          *string `json:"domains,omitempty"`
	Policies         *string `json:"policies,omitempty"`
}

type MandateFilter struct {
	ID      []string              `json:"id,omitempty"`
	Purpose *StringFullTextFilter `json:"purpose,omitempty"`
	And     *MandateFilter        `json:"and,omitempty"`
	Or      *MandateFilter        `json:"or,omitempty"`
	Not     *MandateFilter        `json:"not,omitempty"`
}

type MandateOrder struct {
	Asc  *MandateOrderable `json:"asc,omitempty"`
	Desc *MandateOrderable `json:"desc,omitempty"`
	Then *MandateOrder     `json:"then,omitempty"`
}

type MandatePatch struct {
	Purpose          *string `json:"purpose,omitempty"`
	Responsabilities *string `json:"responsabilities,omitempty"`
	Domains          *string `json:"domains,omitempty"`
	Policies         *string `json:"policies,omitempty"`
}

type MandateRef struct {
	ID               *string `json:"id,omitempty"`
	Purpose          *string `json:"purpose,omitempty"`
	Responsabilities *string `json:"responsabilities,omitempty"`
	Domains          *string `json:"domains,omitempty"`
	Policies         *string `json:"policies,omitempty"`
}

type Node struct {
	ID           string      `json:"id,omitempty"`
	CreatedAt    string      `json:"createdAt,omitempty"`
	CreatedBy    *User       `json:"createdBy,omitempty"`
	Name         string      `json:"name,omitempty"`
	Nameid       string      `json:"nameid,omitempty"`
	Rootnameid   string      `json:"rootnameid,omitempty"`
	Parent       *Node       `json:"parent,omitempty"`
	Children     []*Node     `json:"children,omitempty"`
	Type         NodeType    `json:"type_,omitempty"`
	TensionsOut  []*Tension  `json:"tensions_out,omitempty"`
	TensionsIn   []*Tension  `json:"tensions_in,omitempty"`
	About        *string     `json:"about,omitempty"`
	Mandate      *Mandate    `json:"mandate,omitempty"`
	Docs         []*Tension  `json:"docs,omitempty"`
	Source       *Tension    `json:"source,omitempty"`
	NTensionsOut *int        `json:"n_tensions_out,omitempty"`
	NTensionsIn  *int        `json:"n_tensions_in,omitempty"`
	NChildren    *int        `json:"n_children,omitempty"`
	Stats        *NodeStats  `json:"stats,omitempty"`
	IsRoot       bool        `json:"isRoot"`
	IsPrivate    bool        `json:"isPrivate"`
	Charac       *NodeCharac `json:"charac,omitempty"`
	FirstLink    *User       `json:"first_link,omitempty"`
	SecondLink   *User       `json:"second_link,omitempty"`
	Skills       []string    `json:"skills,omitempty"`
	RoleType     *RoleType   `json:"role_type,omitempty"`
}

type NodeCharac struct {
	ID          string   `json:"id,omitempty"`
	UserCanJoin bool     `json:"userCanJoin"`
	Mode        NodeMode `json:"mode,omitempty"`
}

type NodeCharacFilter struct {
	ID          []string          `json:"id,omitempty"`
	UserCanJoin *bool             `json:"userCanJoin"`
	Mode        *NodeModeHash     `json:"mode,omitempty"`
	And         *NodeCharacFilter `json:"and,omitempty"`
	Or          *NodeCharacFilter `json:"or,omitempty"`
	Not         *NodeCharacFilter `json:"not,omitempty"`
}

type NodeCharacPatch struct {
	UserCanJoin *bool     `json:"userCanJoin"`
	Mode        *NodeMode `json:"mode,omitempty"`
}

type NodeCharacRef struct {
	ID          *string   `json:"id,omitempty"`
	UserCanJoin *bool     `json:"userCanJoin"`
	Mode        *NodeMode `json:"mode,omitempty"`
}

type NodeFilter struct {
	ID         []string                            `json:"id,omitempty"`
	CreatedAt  *DateTimeFilter                     `json:"createdAt,omitempty"`
	Name       *StringTermFilter                   `json:"name,omitempty"`
	Nameid     *StringHashFilterStringRegExpFilter `json:"nameid,omitempty"`
	Rootnameid *StringHashFilterStringRegExpFilter `json:"rootnameid,omitempty"`
	Type       *NodeTypeHash                       `json:"type_,omitempty"`
	About      *StringFullTextFilter               `json:"about,omitempty"`
	IsRoot     *bool                               `json:"isRoot"`
	IsPrivate  *bool                               `json:"isPrivate"`
	Skills     *StringTermFilter                   `json:"skills,omitempty"`
	RoleType   *RoleTypeHash                       `json:"role_type,omitempty"`
	And        *NodeFilter                         `json:"and,omitempty"`
	Or         *NodeFilter                         `json:"or,omitempty"`
	Not        *NodeFilter                         `json:"not,omitempty"`
}

type NodeFragment struct {
	ID         string          `json:"id,omitempty"`
	Name       *string         `json:"name,omitempty"`
	Nameid     *string         `json:"nameid,omitempty"`
	Type       *NodeType       `json:"type_,omitempty"`
	IsPrivate  *bool           `json:"isPrivate"`
	Charac     *NodeCharac     `json:"charac,omitempty"`
	About      *string         `json:"about,omitempty"`
	Mandate    *Mandate        `json:"mandate,omitempty"`
	Children   []*NodeFragment `json:"children,omitempty"`
	FirstLink  *string         `json:"first_link,omitempty"`
	SecondLink *string         `json:"second_link,omitempty"`
	Skills     []string        `json:"skills,omitempty"`
	RoleType   *RoleType       `json:"role_type,omitempty"`
}

type NodeFragmentFilter struct {
	ID  []string            `json:"id,omitempty"`
	Not *NodeFragmentFilter `json:"not,omitempty"`
}

type NodeFragmentOrder struct {
	Asc  *NodeFragmentOrderable `json:"asc,omitempty"`
	Desc *NodeFragmentOrderable `json:"desc,omitempty"`
	Then *NodeFragmentOrder     `json:"then,omitempty"`
}

type NodeFragmentPatch struct {
	Name       *string            `json:"name,omitempty"`
	Nameid     *string            `json:"nameid,omitempty"`
	Type       *NodeType          `json:"type_,omitempty"`
	IsPrivate  *bool              `json:"isPrivate"`
	Charac     *NodeCharacRef     `json:"charac,omitempty"`
	About      *string            `json:"about,omitempty"`
	Mandate    *MandateRef        `json:"mandate,omitempty"`
	Children   []*NodeFragmentRef `json:"children,omitempty"`
	FirstLink  *string            `json:"first_link,omitempty"`
	SecondLink *string            `json:"second_link,omitempty"`
	Skills     []string           `json:"skills,omitempty"`
	RoleType   *RoleType          `json:"role_type,omitempty"`
}

type NodeFragmentRef struct {
	ID         *string            `json:"id,omitempty"`
	Name       *string            `json:"name,omitempty"`
	Nameid     *string            `json:"nameid,omitempty"`
	Type       *NodeType          `json:"type_,omitempty"`
	IsPrivate  *bool              `json:"isPrivate"`
	Charac     *NodeCharacRef     `json:"charac,omitempty"`
	About      *string            `json:"about,omitempty"`
	Mandate    *MandateRef        `json:"mandate,omitempty"`
	Children   []*NodeFragmentRef `json:"children,omitempty"`
	FirstLink  *string            `json:"first_link,omitempty"`
	SecondLink *string            `json:"second_link,omitempty"`
	Skills     []string           `json:"skills,omitempty"`
	RoleType   *RoleType          `json:"role_type,omitempty"`
}

type NodeModeHash struct {
	Eq NodeMode `json:"eq,omitempty"`
}

type NodeOrder struct {
	Asc  *NodeOrderable `json:"asc,omitempty"`
	Desc *NodeOrderable `json:"desc,omitempty"`
	Then *NodeOrder     `json:"then,omitempty"`
}

type NodePatch struct {
	CreatedAt    *string        `json:"createdAt,omitempty"`
	CreatedBy    *UserRef       `json:"createdBy,omitempty"`
	Name         *string        `json:"name,omitempty"`
	Rootnameid   *string        `json:"rootnameid,omitempty"`
	Parent       *NodeRef       `json:"parent,omitempty"`
	Children     []*NodeRef     `json:"children,omitempty"`
	Type         *NodeType      `json:"type_,omitempty"`
	TensionsOut  []*TensionRef  `json:"tensions_out,omitempty"`
	TensionsIn   []*TensionRef  `json:"tensions_in,omitempty"`
	About        *string        `json:"about,omitempty"`
	Mandate      *MandateRef    `json:"mandate,omitempty"`
	Docs         []*TensionRef  `json:"docs,omitempty"`
	Source       *TensionRef    `json:"source,omitempty"`
	NTensionsOut *int           `json:"n_tensions_out,omitempty"`
	NTensionsIn  *int           `json:"n_tensions_in,omitempty"`
	NChildren    *int           `json:"n_children,omitempty"`
	Stats        *NodeStatsRef  `json:"stats,omitempty"`
	IsRoot       *bool          `json:"isRoot"`
	IsPrivate    *bool          `json:"isPrivate"`
	Charac       *NodeCharacRef `json:"charac,omitempty"`
	FirstLink    *UserRef       `json:"first_link,omitempty"`
	SecondLink   *UserRef       `json:"second_link,omitempty"`
	Skills       []string       `json:"skills,omitempty"`
	RoleType     *RoleType      `json:"role_type,omitempty"`
}

type NodeRef struct {
	ID           *string        `json:"id,omitempty"`
	CreatedAt    *string        `json:"createdAt,omitempty"`
	CreatedBy    *UserRef       `json:"createdBy,omitempty"`
	Name         *string        `json:"name,omitempty"`
	Nameid       *string        `json:"nameid,omitempty"`
	Rootnameid   *string        `json:"rootnameid,omitempty"`
	Parent       *NodeRef       `json:"parent,omitempty"`
	Children     []*NodeRef     `json:"children,omitempty"`
	Type         *NodeType      `json:"type_,omitempty"`
	TensionsOut  []*TensionRef  `json:"tensions_out,omitempty"`
	TensionsIn   []*TensionRef  `json:"tensions_in,omitempty"`
	About        *string        `json:"about,omitempty"`
	Mandate      *MandateRef    `json:"mandate,omitempty"`
	Docs         []*TensionRef  `json:"docs,omitempty"`
	Source       *TensionRef    `json:"source,omitempty"`
	NTensionsOut *int           `json:"n_tensions_out,omitempty"`
	NTensionsIn  *int           `json:"n_tensions_in,omitempty"`
	NChildren    *int           `json:"n_children,omitempty"`
	Stats        *NodeStatsRef  `json:"stats,omitempty"`
	IsRoot       *bool          `json:"isRoot"`
	IsPrivate    *bool          `json:"isPrivate"`
	Charac       *NodeCharacRef `json:"charac,omitempty"`
	FirstLink    *UserRef       `json:"first_link,omitempty"`
	SecondLink   *UserRef       `json:"second_link,omitempty"`
	Skills       []string       `json:"skills,omitempty"`
	RoleType     *RoleType      `json:"role_type,omitempty"`
}

type NodeStats struct {
	NMember *int `json:"n_member,omitempty"`
	NGuest  *int `json:"n_guest,omitempty"`
	NCircle *int `json:"n_circle,omitempty"`
	NRole   *int `json:"n_role,omitempty"`
}

type NodeStatsOrder struct {
	Asc  *NodeStatsOrderable `json:"asc,omitempty"`
	Desc *NodeStatsOrderable `json:"desc,omitempty"`
	Then *NodeStatsOrder     `json:"then,omitempty"`
}

type NodeStatsRef struct {
	NMember *int `json:"n_member,omitempty"`
	NGuest  *int `json:"n_guest,omitempty"`
	NCircle *int `json:"n_circle,omitempty"`
	NRole   *int `json:"n_role,omitempty"`
}

type NodeTypeHash struct {
	Eq NodeType `json:"eq,omitempty"`
}

type Post struct {
	ID        string  `json:"id,omitempty"`
	CreatedAt string  `json:"createdAt,omitempty"`
	UpdatedAt *string `json:"updatedAt,omitempty"`
	CreatedBy *User   `json:"createdBy,omitempty"`
	Message   *string `json:"message,omitempty"`
}

type PostFilter struct {
	ID        []string              `json:"id,omitempty"`
	CreatedAt *DateTimeFilter       `json:"createdAt,omitempty"`
	Message   *StringFullTextFilter `json:"message,omitempty"`
	And       *PostFilter           `json:"and,omitempty"`
	Or        *PostFilter           `json:"or,omitempty"`
	Not       *PostFilter           `json:"not,omitempty"`
}

type PostOrder struct {
	Asc  *PostOrderable `json:"asc,omitempty"`
	Desc *PostOrderable `json:"desc,omitempty"`
	Then *PostOrder     `json:"then,omitempty"`
}

type PostPatch struct {
	CreatedAt *string  `json:"createdAt,omitempty"`
	UpdatedAt *string  `json:"updatedAt,omitempty"`
	CreatedBy *UserRef `json:"createdBy,omitempty"`
	Message   *string  `json:"message,omitempty"`
}

type PostRef struct {
	ID string `json:"id,omitempty"`
}

type RoleTypeHash struct {
	Eq *RoleType `json:"eq,omitempty"`
}

type StringExactFilter struct {
	Eq *string `json:"eq,omitempty"`
	Le *string `json:"le,omitempty"`
	Lt *string `json:"lt,omitempty"`
	Ge *string `json:"ge,omitempty"`
	Gt *string `json:"gt,omitempty"`
}

type StringFullTextFilter struct {
	Alloftext *string `json:"alloftext,omitempty"`
	Anyoftext *string `json:"anyoftext,omitempty"`
}

type StringHashFilter struct {
	Eq *string `json:"eq,omitempty"`
}

type StringHashFilterStringRegExpFilter struct {
	Eq     *string `json:"eq,omitempty"`
	Regexp *string `json:"regexp,omitempty"`
}

type StringRegExpFilter struct {
	Regexp *string `json:"regexp,omitempty"`
}

type StringTermFilter struct {
	Allofterms *string `json:"allofterms,omitempty"`
	Anyofterms *string `json:"anyofterms,omitempty"`
}

type Tension struct {
	Nth        *string        `json:"nth,omitempty"`
	Title      string         `json:"title,omitempty"`
	Type       TensionType    `json:"type_,omitempty"`
	Emitter    *Node          `json:"emitter,omitempty"`
	Emitterid  string         `json:"emitterid,omitempty"`
	Receiver   *Node          `json:"receiver,omitempty"`
	Receiverid string         `json:"receiverid,omitempty"`
	Status     TensionStatus  `json:"status,omitempty"`
	Action     *TensionAction `json:"action,omitempty"`
	Labels     []*Label       `json:"labels,omitempty"`
	Comments   []*Comment     `json:"comments,omitempty"`
	Blobs      []*Blob        `json:"blobs,omitempty"`
	History    []*Event       `json:"history,omitempty"`
	NComments  *int           `json:"n_comments,omitempty"`
	NBlobs     *int           `json:"n_blobs,omitempty"`
	ID         string         `json:"id,omitempty"`
	CreatedAt  string         `json:"createdAt,omitempty"`
	UpdatedAt  *string        `json:"updatedAt,omitempty"`
	CreatedBy  *User          `json:"createdBy,omitempty"`
	Message    *string        `json:"message,omitempty"`
}

type TensionEventHash struct {
	Eq TensionEvent `json:"eq,omitempty"`
}

type TensionFilter struct {
	ID         []string                            `json:"id,omitempty"`
	CreatedAt  *DateTimeFilter                     `json:"createdAt,omitempty"`
	Message    *StringFullTextFilter               `json:"message,omitempty"`
	Nth        *StringTermFilter                   `json:"nth,omitempty"`
	Title      *StringFullTextFilter               `json:"title,omitempty"`
	Type       *TensionTypeHash                    `json:"type_,omitempty"`
	Emitterid  *StringHashFilterStringRegExpFilter `json:"emitterid,omitempty"`
	Receiverid *StringHashFilterStringRegExpFilter `json:"receiverid,omitempty"`
	Status     *TensionStatusHash                  `json:"status,omitempty"`
	And        *TensionFilter                      `json:"and,omitempty"`
	Or         *TensionFilter                      `json:"or,omitempty"`
	Not        *TensionFilter                      `json:"not,omitempty"`
}

type TensionOrder struct {
	Asc  *TensionOrderable `json:"asc,omitempty"`
	Desc *TensionOrderable `json:"desc,omitempty"`
	Then *TensionOrder     `json:"then,omitempty"`
}

type TensionPatch struct {
	CreatedAt  *string        `json:"createdAt,omitempty"`
	UpdatedAt  *string        `json:"updatedAt,omitempty"`
	CreatedBy  *UserRef       `json:"createdBy,omitempty"`
	Message    *string        `json:"message,omitempty"`
	Nth        *string        `json:"nth,omitempty"`
	Title      *string        `json:"title,omitempty"`
	Type       *TensionType   `json:"type_,omitempty"`
	Emitter    *NodeRef       `json:"emitter,omitempty"`
	Emitterid  *string        `json:"emitterid,omitempty"`
	Receiver   *NodeRef       `json:"receiver,omitempty"`
	Receiverid *string        `json:"receiverid,omitempty"`
	Status     *TensionStatus `json:"status,omitempty"`
	Action     *TensionAction `json:"action,omitempty"`
	Labels     []*LabelRef    `json:"labels,omitempty"`
	Comments   []*CommentRef  `json:"comments,omitempty"`
	Blobs      []*BlobRef     `json:"blobs,omitempty"`
	History    []*EventRef    `json:"history,omitempty"`
	NComments  *int           `json:"n_comments,omitempty"`
	NBlobs     *int           `json:"n_blobs,omitempty"`
}

type TensionRef struct {
	ID         *string        `json:"id,omitempty"`
	CreatedAt  *string        `json:"createdAt,omitempty"`
	UpdatedAt  *string        `json:"updatedAt,omitempty"`
	CreatedBy  *UserRef       `json:"createdBy,omitempty"`
	Message    *string        `json:"message,omitempty"`
	Nth        *string        `json:"nth,omitempty"`
	Title      *string        `json:"title,omitempty"`
	Type       *TensionType   `json:"type_,omitempty"`
	Emitter    *NodeRef       `json:"emitter,omitempty"`
	Emitterid  *string        `json:"emitterid,omitempty"`
	Receiver   *NodeRef       `json:"receiver,omitempty"`
	Receiverid *string        `json:"receiverid,omitempty"`
	Status     *TensionStatus `json:"status,omitempty"`
	Action     *TensionAction `json:"action,omitempty"`
	Labels     []*LabelRef    `json:"labels,omitempty"`
	Comments   []*CommentRef  `json:"comments,omitempty"`
	Blobs      []*BlobRef     `json:"blobs,omitempty"`
	History    []*EventRef    `json:"history,omitempty"`
	NComments  *int           `json:"n_comments,omitempty"`
	NBlobs     *int           `json:"n_blobs,omitempty"`
}

type TensionStatusHash struct {
	Eq TensionStatus `json:"eq,omitempty"`
}

type TensionTypeHash struct {
	Eq TensionType `json:"eq,omitempty"`
}

type UpdateBlobInput struct {
	Filter *BlobFilter `json:"filter,omitempty"`
	Set    *BlobPatch  `json:"set,omitempty"`
	Remove *BlobPatch  `json:"remove,omitempty"`
}

type UpdateBlobPayload struct {
	Blob    []*Blob `json:"blob,omitempty"`
	NumUids *int    `json:"numUids,omitempty"`
}

type UpdateCommentInput struct {
	Filter *CommentFilter `json:"filter,omitempty"`
	Set    *CommentPatch  `json:"set,omitempty"`
	Remove *CommentPatch  `json:"remove,omitempty"`
}

type UpdateCommentPayload struct {
	Comment []*Comment `json:"comment,omitempty"`
	NumUids *int       `json:"numUids,omitempty"`
}

type UpdateEventInput struct {
	Filter *EventFilter `json:"filter,omitempty"`
	Set    *EventPatch  `json:"set,omitempty"`
	Remove *EventPatch  `json:"remove,omitempty"`
}

type UpdateEventPayload struct {
	Event   []*Event `json:"event,omitempty"`
	NumUids *int     `json:"numUids,omitempty"`
}

type UpdateLabelInput struct {
	Filter *LabelFilter `json:"filter,omitempty"`
	Set    *LabelPatch  `json:"set,omitempty"`
	Remove *LabelPatch  `json:"remove,omitempty"`
}

type UpdateLabelPayload struct {
	Label   []*Label `json:"label,omitempty"`
	NumUids *int     `json:"numUids,omitempty"`
}

type UpdateMandateInput struct {
	Filter *MandateFilter `json:"filter,omitempty"`
	Set    *MandatePatch  `json:"set,omitempty"`
	Remove *MandatePatch  `json:"remove,omitempty"`
}

type UpdateMandatePayload struct {
	Mandate []*Mandate `json:"mandate,omitempty"`
	NumUids *int       `json:"numUids,omitempty"`
}

type UpdateNodeCharacInput struct {
	Filter *NodeCharacFilter `json:"filter,omitempty"`
	Set    *NodeCharacPatch  `json:"set,omitempty"`
	Remove *NodeCharacPatch  `json:"remove,omitempty"`
}

type UpdateNodeCharacPayload struct {
	NodeCharac []*NodeCharac `json:"nodeCharac,omitempty"`
	NumUids    *int          `json:"numUids,omitempty"`
}

type UpdateNodeFragmentInput struct {
	Filter *NodeFragmentFilter `json:"filter,omitempty"`
	Set    *NodeFragmentPatch  `json:"set,omitempty"`
	Remove *NodeFragmentPatch  `json:"remove,omitempty"`
}

type UpdateNodeFragmentPayload struct {
	NodeFragment []*NodeFragment `json:"nodeFragment,omitempty"`
	NumUids      *int            `json:"numUids,omitempty"`
}

type UpdateNodeInput struct {
	Filter *NodeFilter `json:"filter,omitempty"`
	Set    *NodePatch  `json:"set,omitempty"`
	Remove *NodePatch  `json:"remove,omitempty"`
}

type UpdateNodePayload struct {
	Node    []*Node `json:"node,omitempty"`
	NumUids *int    `json:"numUids,omitempty"`
}

type UpdatePostInput struct {
	Filter *PostFilter `json:"filter,omitempty"`
	Set    *PostPatch  `json:"set,omitempty"`
	Remove *PostPatch  `json:"remove,omitempty"`
}

type UpdatePostPayload struct {
	Post    []*Post `json:"post,omitempty"`
	NumUids *int    `json:"numUids,omitempty"`
}

type UpdateTensionInput struct {
	Filter *TensionFilter `json:"filter,omitempty"`
	Set    *TensionPatch  `json:"set,omitempty"`
	Remove *TensionPatch  `json:"remove,omitempty"`
}

type UpdateTensionPayload struct {
	Tension []*Tension `json:"tension,omitempty"`
	NumUids *int       `json:"numUids,omitempty"`
}

type UpdateUserInput struct {
	Filter *UserFilter `json:"filter,omitempty"`
	Set    *UserPatch  `json:"set,omitempty"`
	Remove *UserPatch  `json:"remove,omitempty"`
}

type UpdateUserPayload struct {
	User    []*User `json:"user,omitempty"`
	NumUids *int    `json:"numUids,omitempty"`
}

type User struct {
	ID             string      `json:"id,omitempty"`
	CreatedAt      string      `json:"createdAt,omitempty"`
	Username       string      `json:"username,omitempty"`
	Name           *string     `json:"name,omitempty"`
	Password       string      `json:"password,omitempty"`
	Email          string      `json:"email,omitempty"`
	EmailHash      *string     `json:"emailHash,omitempty"`
	EmailValidated bool        `json:"emailValidated"`
	Rights         *UserRights `json:"rights,omitempty"`
	Roles          []*Node     `json:"roles,omitempty"`
	BackedRoles    []*Node     `json:"backed_roles,omitempty"`
	Bio            *string     `json:"bio,omitempty"`
	Utc            *string     `json:"utc,omitempty"`
}

type UserFilter struct {
	ID       []string          `json:"id,omitempty"`
	Username *StringHashFilter `json:"username,omitempty"`
	Email    *StringHashFilter `json:"email,omitempty"`
	And      *UserFilter       `json:"and,omitempty"`
	Or       *UserFilter       `json:"or,omitempty"`
	Not      *UserFilter       `json:"not,omitempty"`
}

type UserOrder struct {
	Asc  *UserOrderable `json:"asc,omitempty"`
	Desc *UserOrderable `json:"desc,omitempty"`
	Then *UserOrder     `json:"then,omitempty"`
}

type UserPatch struct {
	CreatedAt      *string        `json:"createdAt,omitempty"`
	Name           *string        `json:"name,omitempty"`
	Password       *string        `json:"password,omitempty"`
	Email          *string        `json:"email,omitempty"`
	EmailHash      *string        `json:"emailHash,omitempty"`
	EmailValidated *bool          `json:"emailValidated"`
	Rights         *UserRightsRef `json:"rights,omitempty"`
	Roles          []*NodeRef     `json:"roles,omitempty"`
	BackedRoles    []*NodeRef     `json:"backed_roles,omitempty"`
	Bio            *string        `json:"bio,omitempty"`
	Utc            *string        `json:"utc,omitempty"`
}

type UserRef struct {
	ID             *string        `json:"id,omitempty"`
	CreatedAt      *string        `json:"createdAt,omitempty"`
	Username       *string        `json:"username,omitempty"`
	Name           *string        `json:"name,omitempty"`
	Password       *string        `json:"password,omitempty"`
	Email          *string        `json:"email,omitempty"`
	EmailHash      *string        `json:"emailHash,omitempty"`
	EmailValidated *bool          `json:"emailValidated"`
	Rights         *UserRightsRef `json:"rights,omitempty"`
	Roles          []*NodeRef     `json:"roles,omitempty"`
	BackedRoles    []*NodeRef     `json:"backed_roles,omitempty"`
	Bio            *string        `json:"bio,omitempty"`
	Utc            *string        `json:"utc,omitempty"`
}

type UserRights struct {
	CanLogin      bool `json:"canLogin"`
	CanCreateRoot bool `json:"canCreateRoot"`
}

type UserRightsRef struct {
	CanLogin      *bool `json:"canLogin"`
	CanCreateRoot *bool `json:"canCreateRoot"`
}

type BlobOrderable string

const (
	BlobOrderableCreatedAt  BlobOrderable = "createdAt"
	BlobOrderableUpdatedAt  BlobOrderable = "updatedAt"
	BlobOrderableMessage    BlobOrderable = "message"
	BlobOrderablePushedFlag BlobOrderable = "pushedFlag"
	BlobOrderableMd         BlobOrderable = "md"
)

var AllBlobOrderable = []BlobOrderable{
	BlobOrderableCreatedAt,
	BlobOrderableUpdatedAt,
	BlobOrderableMessage,
	BlobOrderablePushedFlag,
	BlobOrderableMd,
}

func (e BlobOrderable) IsValid() bool {
	switch e {
	case BlobOrderableCreatedAt, BlobOrderableUpdatedAt, BlobOrderableMessage, BlobOrderablePushedFlag, BlobOrderableMd:
		return true
	}
	return false
}

func (e BlobOrderable) String() string {
	return string(e)
}

func (e *BlobOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BlobOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BlobOrderable", str)
	}
	return nil
}

func (e BlobOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type BlobType string

const (
	BlobTypeOnNode      BlobType = "OnNode"
	BlobTypeOnAbout     BlobType = "OnAbout"
	BlobTypeOnMandate   BlobType = "OnMandate"
	BlobTypeOnFirstLink BlobType = "OnFirstLink"
	BlobTypeOnDoc       BlobType = "OnDoc"
)

var AllBlobType = []BlobType{
	BlobTypeOnNode,
	BlobTypeOnAbout,
	BlobTypeOnMandate,
	BlobTypeOnFirstLink,
	BlobTypeOnDoc,
}

func (e BlobType) IsValid() bool {
	switch e {
	case BlobTypeOnNode, BlobTypeOnAbout, BlobTypeOnMandate, BlobTypeOnFirstLink, BlobTypeOnDoc:
		return true
	}
	return false
}

func (e BlobType) String() string {
	return string(e)
}

func (e *BlobType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BlobType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BlobType", str)
	}
	return nil
}

func (e BlobType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CommentOrderable string

const (
	CommentOrderableCreatedAt CommentOrderable = "createdAt"
	CommentOrderableUpdatedAt CommentOrderable = "updatedAt"
	CommentOrderableMessage   CommentOrderable = "message"
	CommentOrderableVoid      CommentOrderable = "_VOID"
)

var AllCommentOrderable = []CommentOrderable{
	CommentOrderableCreatedAt,
	CommentOrderableUpdatedAt,
	CommentOrderableMessage,
	CommentOrderableVoid,
}

func (e CommentOrderable) IsValid() bool {
	switch e {
	case CommentOrderableCreatedAt, CommentOrderableUpdatedAt, CommentOrderableMessage, CommentOrderableVoid:
		return true
	}
	return false
}

func (e CommentOrderable) String() string {
	return string(e)
}

func (e *CommentOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CommentOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CommentOrderable", str)
	}
	return nil
}

func (e CommentOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DgraphIndex string

const (
	DgraphIndexInt      DgraphIndex = "int"
	DgraphIndexFloat    DgraphIndex = "float"
	DgraphIndexBool     DgraphIndex = "bool"
	DgraphIndexHash     DgraphIndex = "hash"
	DgraphIndexExact    DgraphIndex = "exact"
	DgraphIndexTerm     DgraphIndex = "term"
	DgraphIndexFulltext DgraphIndex = "fulltext"
	DgraphIndexTrigram  DgraphIndex = "trigram"
	DgraphIndexRegexp   DgraphIndex = "regexp"
	DgraphIndexYear     DgraphIndex = "year"
	DgraphIndexMonth    DgraphIndex = "month"
	DgraphIndexDay      DgraphIndex = "day"
	DgraphIndexHour     DgraphIndex = "hour"
)

var AllDgraphIndex = []DgraphIndex{
	DgraphIndexInt,
	DgraphIndexFloat,
	DgraphIndexBool,
	DgraphIndexHash,
	DgraphIndexExact,
	DgraphIndexTerm,
	DgraphIndexFulltext,
	DgraphIndexTrigram,
	DgraphIndexRegexp,
	DgraphIndexYear,
	DgraphIndexMonth,
	DgraphIndexDay,
	DgraphIndexHour,
}

func (e DgraphIndex) IsValid() bool {
	switch e {
	case DgraphIndexInt, DgraphIndexFloat, DgraphIndexBool, DgraphIndexHash, DgraphIndexExact, DgraphIndexTerm, DgraphIndexFulltext, DgraphIndexTrigram, DgraphIndexRegexp, DgraphIndexYear, DgraphIndexMonth, DgraphIndexDay, DgraphIndexHour:
		return true
	}
	return false
}

func (e DgraphIndex) String() string {
	return string(e)
}

func (e *DgraphIndex) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DgraphIndex(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DgraphIndex", str)
	}
	return nil
}

func (e DgraphIndex) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EventOrderable string

const (
	EventOrderableCreatedAt EventOrderable = "createdAt"
	EventOrderableUpdatedAt EventOrderable = "updatedAt"
	EventOrderableMessage   EventOrderable = "message"
	EventOrderableOld       EventOrderable = "old"
	EventOrderableNew       EventOrderable = "new"
)

var AllEventOrderable = []EventOrderable{
	EventOrderableCreatedAt,
	EventOrderableUpdatedAt,
	EventOrderableMessage,
	EventOrderableOld,
	EventOrderableNew,
}

func (e EventOrderable) IsValid() bool {
	switch e {
	case EventOrderableCreatedAt, EventOrderableUpdatedAt, EventOrderableMessage, EventOrderableOld, EventOrderableNew:
		return true
	}
	return false
}

func (e EventOrderable) String() string {
	return string(e)
}

func (e *EventOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EventOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EventOrderable", str)
	}
	return nil
}

func (e EventOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type HTTPMethod string

const (
	HTTPMethodGet    HTTPMethod = "GET"
	HTTPMethodPost   HTTPMethod = "POST"
	HTTPMethodPut    HTTPMethod = "PUT"
	HTTPMethodPatch  HTTPMethod = "PATCH"
	HTTPMethodDelete HTTPMethod = "DELETE"
)

var AllHTTPMethod = []HTTPMethod{
	HTTPMethodGet,
	HTTPMethodPost,
	HTTPMethodPut,
	HTTPMethodPatch,
	HTTPMethodDelete,
}

func (e HTTPMethod) IsValid() bool {
	switch e {
	case HTTPMethodGet, HTTPMethodPost, HTTPMethodPut, HTTPMethodPatch, HTTPMethodDelete:
		return true
	}
	return false
}

func (e HTTPMethod) String() string {
	return string(e)
}

func (e *HTTPMethod) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HTTPMethod(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HTTPMethod", str)
	}
	return nil
}

func (e HTTPMethod) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type LabelOrderable string

const (
	LabelOrderableName  LabelOrderable = "name"
	LabelOrderableColor LabelOrderable = "color"
)

var AllLabelOrderable = []LabelOrderable{
	LabelOrderableName,
	LabelOrderableColor,
}

func (e LabelOrderable) IsValid() bool {
	switch e {
	case LabelOrderableName, LabelOrderableColor:
		return true
	}
	return false
}

func (e LabelOrderable) String() string {
	return string(e)
}

func (e *LabelOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LabelOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LabelOrderable", str)
	}
	return nil
}

func (e LabelOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type MandateOrderable string

const (
	MandateOrderablePurpose          MandateOrderable = "purpose"
	MandateOrderableResponsabilities MandateOrderable = "responsabilities"
	MandateOrderableDomains          MandateOrderable = "domains"
	MandateOrderablePolicies         MandateOrderable = "policies"
)

var AllMandateOrderable = []MandateOrderable{
	MandateOrderablePurpose,
	MandateOrderableResponsabilities,
	MandateOrderableDomains,
	MandateOrderablePolicies,
}

func (e MandateOrderable) IsValid() bool {
	switch e {
	case MandateOrderablePurpose, MandateOrderableResponsabilities, MandateOrderableDomains, MandateOrderablePolicies:
		return true
	}
	return false
}

func (e MandateOrderable) String() string {
	return string(e)
}

func (e *MandateOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MandateOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MandateOrderable", str)
	}
	return nil
}

func (e MandateOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Mode string

const (
	ModeBatch  Mode = "BATCH"
	ModeSingle Mode = "SINGLE"
)

var AllMode = []Mode{
	ModeBatch,
	ModeSingle,
}

func (e Mode) IsValid() bool {
	switch e {
	case ModeBatch, ModeSingle:
		return true
	}
	return false
}

func (e Mode) String() string {
	return string(e)
}

func (e *Mode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Mode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Mode", str)
	}
	return nil
}

func (e Mode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type NodeFragmentOrderable string

const (
	NodeFragmentOrderableName       NodeFragmentOrderable = "name"
	NodeFragmentOrderableNameid     NodeFragmentOrderable = "nameid"
	NodeFragmentOrderableAbout      NodeFragmentOrderable = "about"
	NodeFragmentOrderableFirstLink  NodeFragmentOrderable = "first_link"
	NodeFragmentOrderableSecondLink NodeFragmentOrderable = "second_link"
	NodeFragmentOrderableSkills     NodeFragmentOrderable = "skills"
)

var AllNodeFragmentOrderable = []NodeFragmentOrderable{
	NodeFragmentOrderableName,
	NodeFragmentOrderableNameid,
	NodeFragmentOrderableAbout,
	NodeFragmentOrderableFirstLink,
	NodeFragmentOrderableSecondLink,
	NodeFragmentOrderableSkills,
}

func (e NodeFragmentOrderable) IsValid() bool {
	switch e {
	case NodeFragmentOrderableName, NodeFragmentOrderableNameid, NodeFragmentOrderableAbout, NodeFragmentOrderableFirstLink, NodeFragmentOrderableSecondLink, NodeFragmentOrderableSkills:
		return true
	}
	return false
}

func (e NodeFragmentOrderable) String() string {
	return string(e)
}

func (e *NodeFragmentOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NodeFragmentOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NodeFragmentOrderable", str)
	}
	return nil
}

func (e NodeFragmentOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type NodeMode string

const (
	NodeModeChaos       NodeMode = "Chaos"
	NodeModeCoordinated NodeMode = "Coordinated"
)

var AllNodeMode = []NodeMode{
	NodeModeChaos,
	NodeModeCoordinated,
}

func (e NodeMode) IsValid() bool {
	switch e {
	case NodeModeChaos, NodeModeCoordinated:
		return true
	}
	return false
}

func (e NodeMode) String() string {
	return string(e)
}

func (e *NodeMode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NodeMode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NodeMode", str)
	}
	return nil
}

func (e NodeMode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type NodeOrderable string

const (
	NodeOrderableCreatedAt    NodeOrderable = "createdAt"
	NodeOrderableName         NodeOrderable = "name"
	NodeOrderableNameid       NodeOrderable = "nameid"
	NodeOrderableRootnameid   NodeOrderable = "rootnameid"
	NodeOrderableAbout        NodeOrderable = "about"
	NodeOrderableNTensionsOut NodeOrderable = "n_tensions_out"
	NodeOrderableNTensionsIn  NodeOrderable = "n_tensions_in"
	NodeOrderableNChildren    NodeOrderable = "n_children"
	NodeOrderableSkills       NodeOrderable = "skills"
)

var AllNodeOrderable = []NodeOrderable{
	NodeOrderableCreatedAt,
	NodeOrderableName,
	NodeOrderableNameid,
	NodeOrderableRootnameid,
	NodeOrderableAbout,
	NodeOrderableNTensionsOut,
	NodeOrderableNTensionsIn,
	NodeOrderableNChildren,
	NodeOrderableSkills,
}

func (e NodeOrderable) IsValid() bool {
	switch e {
	case NodeOrderableCreatedAt, NodeOrderableName, NodeOrderableNameid, NodeOrderableRootnameid, NodeOrderableAbout, NodeOrderableNTensionsOut, NodeOrderableNTensionsIn, NodeOrderableNChildren, NodeOrderableSkills:
		return true
	}
	return false
}

func (e NodeOrderable) String() string {
	return string(e)
}

func (e *NodeOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NodeOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NodeOrderable", str)
	}
	return nil
}

func (e NodeOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type NodeStatsOrderable string

const (
	NodeStatsOrderableNMember NodeStatsOrderable = "n_member"
	NodeStatsOrderableNGuest  NodeStatsOrderable = "n_guest"
	NodeStatsOrderableNCircle NodeStatsOrderable = "n_circle"
	NodeStatsOrderableNRole   NodeStatsOrderable = "n_role"
)

var AllNodeStatsOrderable = []NodeStatsOrderable{
	NodeStatsOrderableNMember,
	NodeStatsOrderableNGuest,
	NodeStatsOrderableNCircle,
	NodeStatsOrderableNRole,
}

func (e NodeStatsOrderable) IsValid() bool {
	switch e {
	case NodeStatsOrderableNMember, NodeStatsOrderableNGuest, NodeStatsOrderableNCircle, NodeStatsOrderableNRole:
		return true
	}
	return false
}

func (e NodeStatsOrderable) String() string {
	return string(e)
}

func (e *NodeStatsOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NodeStatsOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NodeStatsOrderable", str)
	}
	return nil
}

func (e NodeStatsOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type NodeType string

const (
	NodeTypeCircle NodeType = "Circle"
	NodeTypeRole   NodeType = "Role"
)

var AllNodeType = []NodeType{
	NodeTypeCircle,
	NodeTypeRole,
}

func (e NodeType) IsValid() bool {
	switch e {
	case NodeTypeCircle, NodeTypeRole:
		return true
	}
	return false
}

func (e NodeType) String() string {
	return string(e)
}

func (e *NodeType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NodeType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NodeType", str)
	}
	return nil
}

func (e NodeType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PostOrderable string

const (
	PostOrderableCreatedAt PostOrderable = "createdAt"
	PostOrderableUpdatedAt PostOrderable = "updatedAt"
	PostOrderableMessage   PostOrderable = "message"
)

var AllPostOrderable = []PostOrderable{
	PostOrderableCreatedAt,
	PostOrderableUpdatedAt,
	PostOrderableMessage,
}

func (e PostOrderable) IsValid() bool {
	switch e {
	case PostOrderableCreatedAt, PostOrderableUpdatedAt, PostOrderableMessage:
		return true
	}
	return false
}

func (e PostOrderable) String() string {
	return string(e)
}

func (e *PostOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PostOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PostOrderable", str)
	}
	return nil
}

func (e PostOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RoleType string

const (
	RoleTypeCoordinator RoleType = "Coordinator"
	RoleTypePeer        RoleType = "Peer"
	RoleTypeMember      RoleType = "Member"
	RoleTypeGuest       RoleType = "Guest"
)

var AllRoleType = []RoleType{
	RoleTypeCoordinator,
	RoleTypePeer,
	RoleTypeMember,
	RoleTypeGuest,
}

func (e RoleType) IsValid() bool {
	switch e {
	case RoleTypeCoordinator, RoleTypePeer, RoleTypeMember, RoleTypeGuest:
		return true
	}
	return false
}

func (e RoleType) String() string {
	return string(e)
}

func (e *RoleType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RoleType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RoleType", str)
	}
	return nil
}

func (e RoleType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TensionAction string

const (
	TensionActionNewRole    TensionAction = "NewRole"
	TensionActionNewCircle  TensionAction = "NewCircle"
	TensionActionNewMd      TensionAction = "NewMd"
	TensionActionEditRole   TensionAction = "EditRole"
	TensionActionEditCircle TensionAction = "EditCircle"
	TensionActionEditMd     TensionAction = "EditMd"
)

var AllTensionAction = []TensionAction{
	TensionActionNewRole,
	TensionActionNewCircle,
	TensionActionNewMd,
	TensionActionEditRole,
	TensionActionEditCircle,
	TensionActionEditMd,
}

func (e TensionAction) IsValid() bool {
	switch e {
	case TensionActionNewRole, TensionActionNewCircle, TensionActionNewMd, TensionActionEditRole, TensionActionEditCircle, TensionActionEditMd:
		return true
	}
	return false
}

func (e TensionAction) String() string {
	return string(e)
}

func (e *TensionAction) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TensionAction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TensionAction", str)
	}
	return nil
}

func (e TensionAction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TensionEvent string

const (
	TensionEventCreated       TensionEvent = "Created"
	TensionEventReopened      TensionEvent = "Reopened"
	TensionEventClosed        TensionEvent = "Closed"
	TensionEventTitleUpdated  TensionEvent = "TitleUpdated"
	TensionEventCommentPushed TensionEvent = "CommentPushed"
	TensionEventBlobCreated   TensionEvent = "BlobCreated"
	TensionEventBlobCommitted TensionEvent = "BlobCommitted"
	TensionEventBlobPushed    TensionEvent = "BlobPushed"
)

var AllTensionEvent = []TensionEvent{
	TensionEventCreated,
	TensionEventReopened,
	TensionEventClosed,
	TensionEventTitleUpdated,
	TensionEventCommentPushed,
	TensionEventBlobCreated,
	TensionEventBlobCommitted,
	TensionEventBlobPushed,
}

func (e TensionEvent) IsValid() bool {
	switch e {
	case TensionEventCreated, TensionEventReopened, TensionEventClosed, TensionEventTitleUpdated, TensionEventCommentPushed, TensionEventBlobCreated, TensionEventBlobCommitted, TensionEventBlobPushed:
		return true
	}
	return false
}

func (e TensionEvent) String() string {
	return string(e)
}

func (e *TensionEvent) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TensionEvent(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TensionEvent", str)
	}
	return nil
}

func (e TensionEvent) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TensionOrderable string

const (
	TensionOrderableCreatedAt  TensionOrderable = "createdAt"
	TensionOrderableUpdatedAt  TensionOrderable = "updatedAt"
	TensionOrderableMessage    TensionOrderable = "message"
	TensionOrderableNth        TensionOrderable = "nth"
	TensionOrderableTitle      TensionOrderable = "title"
	TensionOrderableEmitterid  TensionOrderable = "emitterid"
	TensionOrderableReceiverid TensionOrderable = "receiverid"
	TensionOrderableNComments  TensionOrderable = "n_comments"
	TensionOrderableNBlobs     TensionOrderable = "n_blobs"
)

var AllTensionOrderable = []TensionOrderable{
	TensionOrderableCreatedAt,
	TensionOrderableUpdatedAt,
	TensionOrderableMessage,
	TensionOrderableNth,
	TensionOrderableTitle,
	TensionOrderableEmitterid,
	TensionOrderableReceiverid,
	TensionOrderableNComments,
	TensionOrderableNBlobs,
}

func (e TensionOrderable) IsValid() bool {
	switch e {
	case TensionOrderableCreatedAt, TensionOrderableUpdatedAt, TensionOrderableMessage, TensionOrderableNth, TensionOrderableTitle, TensionOrderableEmitterid, TensionOrderableReceiverid, TensionOrderableNComments, TensionOrderableNBlobs:
		return true
	}
	return false
}

func (e TensionOrderable) String() string {
	return string(e)
}

func (e *TensionOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TensionOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TensionOrderable", str)
	}
	return nil
}

func (e TensionOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TensionStatus string

const (
	TensionStatusOpen   TensionStatus = "Open"
	TensionStatusClosed TensionStatus = "Closed"
)

var AllTensionStatus = []TensionStatus{
	TensionStatusOpen,
	TensionStatusClosed,
}

func (e TensionStatus) IsValid() bool {
	switch e {
	case TensionStatusOpen, TensionStatusClosed:
		return true
	}
	return false
}

func (e TensionStatus) String() string {
	return string(e)
}

func (e *TensionStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TensionStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TensionStatus", str)
	}
	return nil
}

func (e TensionStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TensionType string

const (
	TensionTypeGovernance  TensionType = "Governance"
	TensionTypeOperational TensionType = "Operational"
	TensionTypePersonal    TensionType = "Personal"
	TensionTypeHelp        TensionType = "Help"
)

var AllTensionType = []TensionType{
	TensionTypeGovernance,
	TensionTypeOperational,
	TensionTypePersonal,
	TensionTypeHelp,
}

func (e TensionType) IsValid() bool {
	switch e {
	case TensionTypeGovernance, TensionTypeOperational, TensionTypePersonal, TensionTypeHelp:
		return true
	}
	return false
}

func (e TensionType) String() string {
	return string(e)
}

func (e *TensionType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TensionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TensionType", str)
	}
	return nil
}

func (e TensionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UserOrderable string

const (
	UserOrderableCreatedAt UserOrderable = "createdAt"
	UserOrderableUsername  UserOrderable = "username"
	UserOrderableName      UserOrderable = "name"
	UserOrderablePassword  UserOrderable = "password"
	UserOrderableEmail     UserOrderable = "email"
	UserOrderableEmailHash UserOrderable = "emailHash"
	UserOrderableBio       UserOrderable = "bio"
	UserOrderableUtc       UserOrderable = "utc"
)

var AllUserOrderable = []UserOrderable{
	UserOrderableCreatedAt,
	UserOrderableUsername,
	UserOrderableName,
	UserOrderablePassword,
	UserOrderableEmail,
	UserOrderableEmailHash,
	UserOrderableBio,
	UserOrderableUtc,
}

func (e UserOrderable) IsValid() bool {
	switch e {
	case UserOrderableCreatedAt, UserOrderableUsername, UserOrderableName, UserOrderablePassword, UserOrderableEmail, UserOrderableEmailHash, UserOrderableBio, UserOrderableUtc:
		return true
	}
	return false
}

func (e UserOrderable) String() string {
	return string(e)
}

func (e *UserOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserOrderable", str)
	}
	return nil
}

func (e UserOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
