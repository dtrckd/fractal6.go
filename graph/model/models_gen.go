// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
)

type AddBlobInput struct {
	CreatedBy    *UserRef         `json:"createdBy,omitempty"`
	CreatedAt    string           `json:"createdAt,omitempty"`
	UpdatedAt    *string          `json:"updatedAt,omitempty"`
	Message      *string          `json:"message,omitempty"`
	Tension      *TensionRef      `json:"tension,omitempty"`
	BlobType     BlobType         `json:"blob_type,omitempty"`
	PushedFlag   *string          `json:"pushedFlag,omitempty"`
	ArchivedFlag *string          `json:"archivedFlag,omitempty"`
	Node         *NodeFragmentRef `json:"node,omitempty"`
	Md           *string          `json:"md,omitempty"`
}

type AddBlobPayload struct {
	Blob    []*Blob `json:"blob,omitempty"`
	NumUids *int    `json:"numUids,omitempty"`
}

type AddCommentInput struct {
	CreatedBy *UserRef `json:"createdBy,omitempty"`
	CreatedAt string   `json:"createdAt,omitempty"`
	UpdatedAt *string  `json:"updatedAt,omitempty"`
	Message   *string  `json:"message,omitempty"`
	Void      *string  `json:"_VOID,omitempty"`
}

type AddCommentPayload struct {
	Comment []*Comment `json:"comment,omitempty"`
	NumUids *int       `json:"numUids,omitempty"`
}

type AddContractInput struct {
	CreatedBy    *UserRef          `json:"createdBy,omitempty"`
	CreatedAt    string            `json:"createdAt,omitempty"`
	UpdatedAt    *string           `json:"updatedAt,omitempty"`
	Message      *string           `json:"message,omitempty"`
	Tension      *TensionRef       `json:"tension,omitempty"`
	Status       ContractStatus    `json:"status,omitempty"`
	ContractType ContractType      `json:"contract_type,omitempty"`
	ClosedAt     *string           `json:"closedAt,omitempty"`
	Event        *EventFragmentRef `json:"event,omitempty"`
	Candidates   []*UserRef        `json:"candidates,omitempty"`
	Participants []*VoteRef        `json:"participants,omitempty"`
	Comments     []*CommentRef     `json:"comments,omitempty"`
}

type AddContractPayload struct {
	Contract []*Contract `json:"contract,omitempty"`
	NumUids  *int        `json:"numUids,omitempty"`
}

type AddEventFragmentInput struct {
	EventType TensionEvent `json:"event_type,omitempty"`
	Old       *string      `json:"old,omitempty"`
	New       *string      `json:"new,omitempty"`
}

type AddEventFragmentPayload struct {
	EventFragment []*EventFragment `json:"eventFragment,omitempty"`
	NumUids       *int             `json:"numUids,omitempty"`
}

type AddEventInput struct {
	CreatedBy *UserRef     `json:"createdBy,omitempty"`
	CreatedAt string       `json:"createdAt,omitempty"`
	UpdatedAt *string      `json:"updatedAt,omitempty"`
	Message   *string      `json:"message,omitempty"`
	Tension   *TensionRef  `json:"tension,omitempty"`
	EventType TensionEvent `json:"event_type,omitempty"`
	Old       *string      `json:"old,omitempty"`
	New       *string      `json:"new,omitempty"`
}

type AddEventPayload struct {
	Event   []*Event `json:"event,omitempty"`
	NumUids *int     `json:"numUids,omitempty"`
}

type AddLabelInput struct {
	Rootnameid  string        `json:"rootnameid,omitempty"`
	Name        string        `json:"name,omitempty"`
	Description *string       `json:"description,omitempty"`
	Color       *string       `json:"color,omitempty"`
	Tensions    []*TensionRef `json:"tensions,omitempty"`
	Nodes       []*NodeRef    `json:"nodes,omitempty"`
	NNodes      *int          `json:"n_nodes,omitempty"`
	NTensions   *int          `json:"n_tensions,omitempty"`
}

type AddLabelPayload struct {
	Label   []*Label `json:"label,omitempty"`
	NumUids *int     `json:"numUids,omitempty"`
}

type AddMandateInput struct {
	Purpose          string  `json:"purpose,omitempty"`
	Responsabilities *string `json:"responsabilities,omitempty"`
	Domains          *string `json:"domains,omitempty"`
	Policies         *string `json:"policies,omitempty"`
}

type AddMandatePayload struct {
	Mandate []*Mandate `json:"mandate,omitempty"`
	NumUids *int       `json:"numUids,omitempty"`
}

type AddNodeCharacInput struct {
	UserCanJoin bool     `json:"userCanJoin"`
	Mode        NodeMode `json:"mode,omitempty"`
}

type AddNodeCharacPayload struct {
	NodeCharac []*NodeCharac `json:"nodeCharac,omitempty"`
	NumUids    *int          `json:"numUids,omitempty"`
}

type AddNodeFragmentInput struct {
	Name       *string            `json:"name,omitempty"`
	Nameid     *string            `json:"nameid,omitempty"`
	Type       *NodeType          `json:"type_,omitempty"`
	IsPrivate  *bool              `json:"isPrivate"`
	Charac     *NodeCharacRef     `json:"charac,omitempty"`
	About      *string            `json:"about,omitempty"`
	Mandate    *MandateRef        `json:"mandate,omitempty"`
	Children   []*NodeFragmentRef `json:"children,omitempty"`
	FirstLink  *string            `json:"first_link,omitempty"`
	SecondLink *string            `json:"second_link,omitempty"`
	Skills     []string           `json:"skills,omitempty"`
	RoleType   *RoleType          `json:"role_type,omitempty"`
}

type AddNodeFragmentPayload struct {
	NodeFragment []*NodeFragment `json:"nodeFragment,omitempty"`
	NumUids      *int            `json:"numUids,omitempty"`
}

type AddNodeInput struct {
	CreatedBy    *UserRef       `json:"createdBy,omitempty"`
	CreatedAt    string         `json:"createdAt,omitempty"`
	UpdatedAt    *string        `json:"updatedAt,omitempty"`
	Name         string         `json:"name,omitempty"`
	Nameid       string         `json:"nameid,omitempty"`
	Rootnameid   string         `json:"rootnameid,omitempty"`
	Parent       *NodeRef       `json:"parent,omitempty"`
	Children     []*NodeRef     `json:"children,omitempty"`
	Type         NodeType       `json:"type_,omitempty"`
	TensionsOut  []*TensionRef  `json:"tensions_out,omitempty"`
	TensionsIn   []*TensionRef  `json:"tensions_in,omitempty"`
	About        *string        `json:"about,omitempty"`
	Mandate      *MandateRef    `json:"mandate,omitempty"`
	Docs         []*BlobRef     `json:"docs,omitempty"`
	Source       *BlobRef       `json:"source,omitempty"`
	NTensionsOut *int           `json:"n_tensions_out,omitempty"`
	NTensionsIn  *int           `json:"n_tensions_in,omitempty"`
	NChildren    *int           `json:"n_children,omitempty"`
	Stats        *NodeStatsRef  `json:"stats,omitempty"`
	IsRoot       bool           `json:"isRoot"`
	IsPersonal   *bool          `json:"isPersonal"`
	IsPrivate    bool           `json:"isPrivate"`
	IsArchived   bool           `json:"isArchived"`
	Charac       *NodeCharacRef `json:"charac,omitempty"`
	Rights       int            `json:"rights,omitempty"`
	Labels       []*LabelRef    `json:"labels,omitempty"`
	FirstLink    *UserRef       `json:"first_link,omitempty"`
	SecondLink   *UserRef       `json:"second_link,omitempty"`
	Skills       []string       `json:"skills,omitempty"`
	RoleType     *RoleType      `json:"role_type,omitempty"`
	Contracts    []*VoteRef     `json:"contracts,omitempty"`
	Shared       *SharedNodeRef `json:"shared,omitempty"`
}

type AddNodePayload struct {
	Node    []*Node `json:"node,omitempty"`
	NumUids *int    `json:"numUids,omitempty"`
}

type AddNodeStatsInput struct {
	NMember *int `json:"n_member,omitempty"`
	NGuest  *int `json:"n_guest,omitempty"`
	NCircle *int `json:"n_circle,omitempty"`
	NRole   *int `json:"n_role,omitempty"`
}

type AddNodeStatsPayload struct {
	NodeStats []*NodeStats `json:"nodeStats,omitempty"`
	NumUids   *int         `json:"numUids,omitempty"`
}

type AddSharedNodeInput struct {
	NLabels         *int `json:"n_labels,omitempty"`
	NTensions       *int `json:"n_tensions,omitempty"`
	NClosedTensions *int `json:"n_closed_tensions,omitempty"`
}

type AddSharedNodePayload struct {
	SharedNode []*SharedNode `json:"sharedNode,omitempty"`
	NumUids    *int          `json:"numUids,omitempty"`
}

type AddTensionInput struct {
	CreatedBy  *UserRef       `json:"createdBy,omitempty"`
	CreatedAt  string         `json:"createdAt,omitempty"`
	UpdatedAt  *string        `json:"updatedAt,omitempty"`
	Message    *string        `json:"message,omitempty"`
	Emitterid  string         `json:"emitterid,omitempty"`
	Emitter    *NodeRef       `json:"emitter,omitempty"`
	Receiverid string         `json:"receiverid,omitempty"`
	Receiver   *NodeRef       `json:"receiver,omitempty"`
	Nth        *string        `json:"nth,omitempty"`
	Title      string         `json:"title,omitempty"`
	Type       TensionType    `json:"type_,omitempty"`
	Status     TensionStatus  `json:"status,omitempty"`
	Assignees  []*UserRef     `json:"assignees,omitempty"`
	Labels     []*LabelRef    `json:"labels,omitempty"`
	Comments   []*CommentRef  `json:"comments,omitempty"`
	Action     *TensionAction `json:"action,omitempty"`
	Blobs      []*BlobRef     `json:"blobs,omitempty"`
	Contracts  []*ContractRef `json:"contracts,omitempty"`
	History    []*EventRef    `json:"history,omitempty"`
	NComments  *int           `json:"n_comments,omitempty"`
	NBlobs     *int           `json:"n_blobs,omitempty"`
}

type AddTensionPayload struct {
	Tension []*Tension `json:"tension,omitempty"`
	NumUids *int       `json:"numUids,omitempty"`
}

type AddUserInput struct {
	CreatedAt        string         `json:"createdAt,omitempty"`
	LastAck          string         `json:"lastAck,omitempty"`
	Username         string         `json:"username,omitempty"`
	Name             *string        `json:"name,omitempty"`
	Password         string         `json:"password,omitempty"`
	Email            string         `json:"email,omitempty"`
	EmailHash        *string        `json:"emailHash,omitempty"`
	EmailValidated   bool           `json:"emailValidated"`
	Rights           *UserRightsRef `json:"rights,omitempty"`
	Roles            []*NodeRef     `json:"roles,omitempty"`
	BackedRoles      []*NodeRef     `json:"backed_roles,omitempty"`
	TensionsCreated  []*TensionRef  `json:"tensions_created,omitempty"`
	TensionsAssigned []*TensionRef  `json:"tensions_assigned,omitempty"`
	Contracts        []*ContractRef `json:"contracts,omitempty"`
	Bio              *string        `json:"bio,omitempty"`
	Utc              *string        `json:"utc,omitempty"`
}

type AddUserPayload struct {
	User    []*User `json:"user,omitempty"`
	NumUids *int    `json:"numUids,omitempty"`
}

type AddUserRightsInput struct {
	CanLogin      bool     `json:"canLogin"`
	CanCreateRoot bool     `json:"canCreateRoot"`
	MaxPublicOrga int      `json:"maxPublicOrga,omitempty"`
	Type          UserType `json:"type_,omitempty"`
}

type AddUserRightsPayload struct {
	UserRights []*UserRights `json:"userRights,omitempty"`
	NumUids    *int          `json:"numUids,omitempty"`
}

type AddVoteInput struct {
	Contract *ContractRef `json:"contract,omitempty"`
	Node     *NodeRef     `json:"node,omitempty"`
	Data     []int        `json:"data,omitempty"`
}

type AddVotePayload struct {
	Vote    []*Vote `json:"vote,omitempty"`
	NumUids *int    `json:"numUids,omitempty"`
}

type AuthRule struct {
	And  []*AuthRule `json:"and,omitempty"`
	Or   []*AuthRule `json:"or,omitempty"`
	Not  *AuthRule   `json:"not,omitempty"`
	Rule *string     `json:"rule,omitempty"`
}

type Blob struct {
	Tension      *Tension      `json:"tension,omitempty"`
	BlobType     BlobType      `json:"blob_type,omitempty"`
	PushedFlag   *string       `json:"pushedFlag,omitempty"`
	ArchivedFlag *string       `json:"archivedFlag,omitempty"`
	Node         *NodeFragment `json:"node,omitempty"`
	Md           *string       `json:"md,omitempty"`
	ID           string        `json:"id,omitempty"`
	CreatedBy    *User         `json:"createdBy,omitempty"`
	CreatedAt    string        `json:"createdAt,omitempty"`
	UpdatedAt    *string       `json:"updatedAt,omitempty"`
	Message      *string       `json:"message,omitempty"`
}

type BlobAggregateResult struct {
	Count           *int    `json:"count,omitempty"`
	CreatedAtMin    *string `json:"createdAtMin,omitempty"`
	CreatedAtMax    *string `json:"createdAtMax,omitempty"`
	UpdatedAtMin    *string `json:"updatedAtMin,omitempty"`
	UpdatedAtMax    *string `json:"updatedAtMax,omitempty"`
	MessageMin      *string `json:"messageMin,omitempty"`
	MessageMax      *string `json:"messageMax,omitempty"`
	PushedFlagMin   *string `json:"pushedFlagMin,omitempty"`
	PushedFlagMax   *string `json:"pushedFlagMax,omitempty"`
	ArchivedFlagMin *string `json:"archivedFlagMin,omitempty"`
	ArchivedFlagMax *string `json:"archivedFlagMax,omitempty"`
	MdMin           *string `json:"mdMin,omitempty"`
	MdMax           *string `json:"mdMax,omitempty"`
}

type BlobFilter struct {
	ID           []string              `json:"id,omitempty"`
	CreatedAt    *DateTimeFilter       `json:"createdAt,omitempty"`
	Message      *StringFullTextFilter `json:"message,omitempty"`
	BlobType     *BlobTypeHash         `json:"blob_type,omitempty"`
	PushedFlag   *DateTimeFilter       `json:"pushedFlag,omitempty"`
	ArchivedFlag *DateTimeFilter       `json:"archivedFlag,omitempty"`
	Has          []*BlobHasFilter      `json:"has,omitempty"`
	And          []*BlobFilter         `json:"and,omitempty"`
	Or           []*BlobFilter         `json:"or,omitempty"`
	Not          *BlobFilter           `json:"not,omitempty"`
}

type BlobOrder struct {
	Asc  *BlobOrderable `json:"asc,omitempty"`
	Desc *BlobOrderable `json:"desc,omitempty"`
	Then *BlobOrder     `json:"then,omitempty"`
}

type BlobPatch struct {
	CreatedBy    *UserRef         `json:"createdBy,omitempty"`
	CreatedAt    *string          `json:"createdAt,omitempty"`
	UpdatedAt    *string          `json:"updatedAt,omitempty"`
	Message      *string          `json:"message,omitempty"`
	Tension      *TensionRef      `json:"tension,omitempty"`
	BlobType     *BlobType        `json:"blob_type,omitempty"`
	PushedFlag   *string          `json:"pushedFlag,omitempty"`
	ArchivedFlag *string          `json:"archivedFlag,omitempty"`
	Node         *NodeFragmentRef `json:"node,omitempty"`
	Md           *string          `json:"md,omitempty"`
}

type BlobRef struct {
	ID           *string          `json:"id,omitempty"`
	CreatedBy    *UserRef         `json:"createdBy,omitempty"`
	CreatedAt    *string          `json:"createdAt,omitempty"`
	UpdatedAt    *string          `json:"updatedAt,omitempty"`
	Message      *string          `json:"message,omitempty"`
	Tension      *TensionRef      `json:"tension,omitempty"`
	BlobType     *BlobType        `json:"blob_type,omitempty"`
	PushedFlag   *string          `json:"pushedFlag,omitempty"`
	ArchivedFlag *string          `json:"archivedFlag,omitempty"`
	Node         *NodeFragmentRef `json:"node,omitempty"`
	Md           *string          `json:"md,omitempty"`
}

type BlobTypeHash struct {
	Eq *BlobType   `json:"eq,omitempty"`
	In []*BlobType `json:"in,omitempty"`
}

type Comment struct {
	Message   string  `json:"message,omitempty"`
	ID        string  `json:"id,omitempty"`
	CreatedBy *User   `json:"createdBy,omitempty"`
	CreatedAt string  `json:"createdAt,omitempty"`
	UpdatedAt *string `json:"updatedAt,omitempty"`
}

type CommentAggregateResult struct {
	Count        *int    `json:"count,omitempty"`
	CreatedAtMin *string `json:"createdAtMin,omitempty"`
	CreatedAtMax *string `json:"createdAtMax,omitempty"`
	UpdatedAtMin *string `json:"updatedAtMin,omitempty"`
	UpdatedAtMax *string `json:"updatedAtMax,omitempty"`
	MessageMin   *string `json:"messageMin,omitempty"`
	MessageMax   *string `json:"messageMax,omitempty"`
	VOIDMin      *string `json:"_VOIDMin,omitempty"`
	VOIDMax      *string `json:"_VOIDMax,omitempty"`
}

type CommentFilter struct {
	ID        []string              `json:"id,omitempty"`
	CreatedAt *DateTimeFilter       `json:"createdAt,omitempty"`
	Message   *StringFullTextFilter `json:"message,omitempty"`
	Has       []*CommentHasFilter   `json:"has,omitempty"`
	And       []*CommentFilter      `json:"and,omitempty"`
	Or        []*CommentFilter      `json:"or,omitempty"`
	Not       *CommentFilter        `json:"not,omitempty"`
}

type CommentOrder struct {
	Asc  *CommentOrderable `json:"asc,omitempty"`
	Desc *CommentOrderable `json:"desc,omitempty"`
	Then *CommentOrder     `json:"then,omitempty"`
}

type CommentPatch struct {
	CreatedBy *UserRef `json:"createdBy,omitempty"`
	CreatedAt *string  `json:"createdAt,omitempty"`
	UpdatedAt *string  `json:"updatedAt,omitempty"`
	Message   *string  `json:"message,omitempty"`
	Void      *string  `json:"_VOID,omitempty"`
}

type CommentRef struct {
	ID        *string  `json:"id,omitempty"`
	CreatedBy *UserRef `json:"createdBy,omitempty"`
	CreatedAt *string  `json:"createdAt,omitempty"`
	UpdatedAt *string  `json:"updatedAt,omitempty"`
	Message   *string  `json:"message,omitempty"`
	Void      *string  `json:"_VOID,omitempty"`
}

type ContainsFilter struct {
	Point   *PointRef   `json:"point,omitempty"`
	Polygon *PolygonRef `json:"polygon,omitempty"`
}

type Contract struct {
	Tension      *Tension       `json:"tension,omitempty"`
	Status       ContractStatus `json:"status,omitempty"`
	ContractType ContractType   `json:"contract_type,omitempty"`
	ClosedAt     *string        `json:"closedAt,omitempty"`
	Event        *EventFragment `json:"event,omitempty"`
	Candidates   []*User        `json:"candidates,omitempty"`
	Participants []*Vote        `json:"participants,omitempty"`
	Comments     []*Comment     `json:"comments,omitempty"`
	ID           string         `json:"id,omitempty"`
	CreatedBy    *User          `json:"createdBy,omitempty"`
	CreatedAt    string         `json:"createdAt,omitempty"`
	UpdatedAt    *string        `json:"updatedAt,omitempty"`
	Message      *string        `json:"message,omitempty"`
}

type ContractAggregateResult struct {
	Count        *int    `json:"count,omitempty"`
	CreatedAtMin *string `json:"createdAtMin,omitempty"`
	CreatedAtMax *string `json:"createdAtMax,omitempty"`
	UpdatedAtMin *string `json:"updatedAtMin,omitempty"`
	UpdatedAtMax *string `json:"updatedAtMax,omitempty"`
	MessageMin   *string `json:"messageMin,omitempty"`
	MessageMax   *string `json:"messageMax,omitempty"`
	ClosedAtMin  *string `json:"closedAtMin,omitempty"`
	ClosedAtMax  *string `json:"closedAtMax,omitempty"`
}

type ContractFilter struct {
	ID           []string              `json:"id,omitempty"`
	CreatedAt    *DateTimeFilter       `json:"createdAt,omitempty"`
	Message      *StringFullTextFilter `json:"message,omitempty"`
	Status       *ContractStatusHash   `json:"status,omitempty"`
	ContractType *ContractTypeHash     `json:"contract_type,omitempty"`
	ClosedAt     *DateTimeFilter       `json:"closedAt,omitempty"`
	Has          []*ContractHasFilter  `json:"has,omitempty"`
	And          []*ContractFilter     `json:"and,omitempty"`
	Or           []*ContractFilter     `json:"or,omitempty"`
	Not          *ContractFilter       `json:"not,omitempty"`
}

type ContractOrder struct {
	Asc  *ContractOrderable `json:"asc,omitempty"`
	Desc *ContractOrderable `json:"desc,omitempty"`
	Then *ContractOrder     `json:"then,omitempty"`
}

type ContractPatch struct {
	CreatedBy    *UserRef          `json:"createdBy,omitempty"`
	CreatedAt    *string           `json:"createdAt,omitempty"`
	UpdatedAt    *string           `json:"updatedAt,omitempty"`
	Message      *string           `json:"message,omitempty"`
	Tension      *TensionRef       `json:"tension,omitempty"`
	Status       *ContractStatus   `json:"status,omitempty"`
	ContractType *ContractType     `json:"contract_type,omitempty"`
	ClosedAt     *string           `json:"closedAt,omitempty"`
	Event        *EventFragmentRef `json:"event,omitempty"`
	Candidates   []*UserRef        `json:"candidates,omitempty"`
	Participants []*VoteRef        `json:"participants,omitempty"`
	Comments     []*CommentRef     `json:"comments,omitempty"`
}

type ContractRef struct {
	ID           *string           `json:"id,omitempty"`
	CreatedBy    *UserRef          `json:"createdBy,omitempty"`
	CreatedAt    *string           `json:"createdAt,omitempty"`
	UpdatedAt    *string           `json:"updatedAt,omitempty"`
	Message      *string           `json:"message,omitempty"`
	Tension      *TensionRef       `json:"tension,omitempty"`
	Status       *ContractStatus   `json:"status,omitempty"`
	ContractType *ContractType     `json:"contract_type,omitempty"`
	ClosedAt     *string           `json:"closedAt,omitempty"`
	Event        *EventFragmentRef `json:"event,omitempty"`
	Candidates   []*UserRef        `json:"candidates,omitempty"`
	Participants []*VoteRef        `json:"participants,omitempty"`
	Comments     []*CommentRef     `json:"comments,omitempty"`
}

type ContractStatusHash struct {
	Eq *ContractStatus   `json:"eq,omitempty"`
	In []*ContractStatus `json:"in,omitempty"`
}

type ContractTypeHash struct {
	Eq *ContractType   `json:"eq,omitempty"`
	In []*ContractType `json:"in,omitempty"`
}

type CustomHTTP struct {
	URL                  string     `json:"url,omitempty"`
	Method               HTTPMethod `json:"method,omitempty"`
	Body                 *string    `json:"body,omitempty"`
	Graphql              *string    `json:"graphql,omitempty"`
	Mode                 *Mode      `json:"mode,omitempty"`
	ForwardHeaders       []string   `json:"forwardHeaders,omitempty"`
	SecretHeaders        []string   `json:"secretHeaders,omitempty"`
	IntrospectionHeaders []string   `json:"introspectionHeaders,omitempty"`
	SkipIntrospection    *bool      `json:"skipIntrospection"`
}

type DateTimeFilter struct {
	Eq      *string        `json:"eq,omitempty"`
	In      []*string      `json:"in,omitempty"`
	Le      *string        `json:"le,omitempty"`
	Lt      *string        `json:"lt,omitempty"`
	Ge      *string        `json:"ge,omitempty"`
	Gt      *string        `json:"gt,omitempty"`
	Between *DateTimeRange `json:"between,omitempty"`
}

type DateTimeRange struct {
	Min string `json:"min,omitempty"`
	Max string `json:"max,omitempty"`
}

type DeleteBlobPayload struct {
	Blob    []*Blob `json:"blob,omitempty"`
	Msg     *string `json:"msg,omitempty"`
	NumUids *int    `json:"numUids,omitempty"`
}

type DeleteCommentPayload struct {
	Comment []*Comment `json:"comment,omitempty"`
	Msg     *string    `json:"msg,omitempty"`
	NumUids *int       `json:"numUids,omitempty"`
}

type DeleteContractPayload struct {
	Contract []*Contract `json:"contract,omitempty"`
	Msg      *string     `json:"msg,omitempty"`
	NumUids  *int        `json:"numUids,omitempty"`
}

type DeleteEventFragmentPayload struct {
	EventFragment []*EventFragment `json:"eventFragment,omitempty"`
	Msg           *string          `json:"msg,omitempty"`
	NumUids       *int             `json:"numUids,omitempty"`
}

type DeleteEventPayload struct {
	Event   []*Event `json:"event,omitempty"`
	Msg     *string  `json:"msg,omitempty"`
	NumUids *int     `json:"numUids,omitempty"`
}

type DeleteLabelPayload struct {
	Label   []*Label `json:"label,omitempty"`
	Msg     *string  `json:"msg,omitempty"`
	NumUids *int     `json:"numUids,omitempty"`
}

type DeleteMandatePayload struct {
	Mandate []*Mandate `json:"mandate,omitempty"`
	Msg     *string    `json:"msg,omitempty"`
	NumUids *int       `json:"numUids,omitempty"`
}

type DeleteNodeCharacPayload struct {
	NodeCharac []*NodeCharac `json:"nodeCharac,omitempty"`
	Msg        *string       `json:"msg,omitempty"`
	NumUids    *int          `json:"numUids,omitempty"`
}

type DeleteNodeFragmentPayload struct {
	NodeFragment []*NodeFragment `json:"nodeFragment,omitempty"`
	Msg          *string         `json:"msg,omitempty"`
	NumUids      *int            `json:"numUids,omitempty"`
}

type DeleteNodePayload struct {
	Node    []*Node `json:"node,omitempty"`
	Msg     *string `json:"msg,omitempty"`
	NumUids *int    `json:"numUids,omitempty"`
}

type DeleteNodeStatsPayload struct {
	NodeStats []*NodeStats `json:"nodeStats,omitempty"`
	Msg       *string      `json:"msg,omitempty"`
	NumUids   *int         `json:"numUids,omitempty"`
}

type DeletePostPayload struct {
	Post    []*Post `json:"post,omitempty"`
	Msg     *string `json:"msg,omitempty"`
	NumUids *int    `json:"numUids,omitempty"`
}

type DeleteSharedNodePayload struct {
	SharedNode []*SharedNode `json:"sharedNode,omitempty"`
	Msg        *string       `json:"msg,omitempty"`
	NumUids    *int          `json:"numUids,omitempty"`
}

type DeleteTensionPayload struct {
	Tension []*Tension `json:"tension,omitempty"`
	Msg     *string    `json:"msg,omitempty"`
	NumUids *int       `json:"numUids,omitempty"`
}

type DeleteUserPayload struct {
	User    []*User `json:"user,omitempty"`
	Msg     *string `json:"msg,omitempty"`
	NumUids *int    `json:"numUids,omitempty"`
}

type DeleteUserRightsPayload struct {
	UserRights []*UserRights `json:"userRights,omitempty"`
	Msg        *string       `json:"msg,omitempty"`
	NumUids    *int          `json:"numUids,omitempty"`
}

type DeleteVotePayload struct {
	Vote    []*Vote `json:"vote,omitempty"`
	Msg     *string `json:"msg,omitempty"`
	NumUids *int    `json:"numUids,omitempty"`
}

type Event struct {
	Tension   *Tension     `json:"tension,omitempty"`
	EventType TensionEvent `json:"event_type,omitempty"`
	Old       *string      `json:"old,omitempty"`
	New       *string      `json:"new,omitempty"`
	ID        string       `json:"id,omitempty"`
	CreatedBy *User        `json:"createdBy,omitempty"`
	CreatedAt string       `json:"createdAt,omitempty"`
	UpdatedAt *string      `json:"updatedAt,omitempty"`
	Message   *string      `json:"message,omitempty"`
}

type EventAggregateResult struct {
	Count        *int    `json:"count,omitempty"`
	CreatedAtMin *string `json:"createdAtMin,omitempty"`
	CreatedAtMax *string `json:"createdAtMax,omitempty"`
	UpdatedAtMin *string `json:"updatedAtMin,omitempty"`
	UpdatedAtMax *string `json:"updatedAtMax,omitempty"`
	MessageMin   *string `json:"messageMin,omitempty"`
	MessageMax   *string `json:"messageMax,omitempty"`
	OldMin       *string `json:"oldMin,omitempty"`
	OldMax       *string `json:"oldMax,omitempty"`
	NewMin       *string `json:"newMin,omitempty"`
	NewMax       *string `json:"newMax,omitempty"`
}

type EventFilter struct {
	ID        []string              `json:"id,omitempty"`
	CreatedAt *DateTimeFilter       `json:"createdAt,omitempty"`
	Message   *StringFullTextFilter `json:"message,omitempty"`
	EventType *TensionEventHash     `json:"event_type,omitempty"`
	Has       []*EventHasFilter     `json:"has,omitempty"`
	And       []*EventFilter        `json:"and,omitempty"`
	Or        []*EventFilter        `json:"or,omitempty"`
	Not       *EventFilter          `json:"not,omitempty"`
}

type EventFragment struct {
	EventType TensionEvent `json:"event_type,omitempty"`
	Old       *string      `json:"old,omitempty"`
	New       *string      `json:"new,omitempty"`
}

type EventFragmentAggregateResult struct {
	Count  *int    `json:"count,omitempty"`
	OldMin *string `json:"oldMin,omitempty"`
	OldMax *string `json:"oldMax,omitempty"`
	NewMin *string `json:"newMin,omitempty"`
	NewMax *string `json:"newMax,omitempty"`
}

type EventFragmentFilter struct {
	EventType *TensionEventHash         `json:"event_type,omitempty"`
	Has       []*EventFragmentHasFilter `json:"has,omitempty"`
	And       []*EventFragmentFilter    `json:"and,omitempty"`
	Or        []*EventFragmentFilter    `json:"or,omitempty"`
	Not       *EventFragmentFilter      `json:"not,omitempty"`
}

type EventFragmentOrder struct {
	Asc  *EventFragmentOrderable `json:"asc,omitempty"`
	Desc *EventFragmentOrderable `json:"desc,omitempty"`
	Then *EventFragmentOrder     `json:"then,omitempty"`
}

type EventFragmentPatch struct {
	EventType *TensionEvent `json:"event_type,omitempty"`
	Old       *string       `json:"old,omitempty"`
	New       *string       `json:"new,omitempty"`
}

type EventFragmentRef struct {
	EventType *TensionEvent `json:"event_type,omitempty"`
	Old       *string       `json:"old,omitempty"`
	New       *string       `json:"new,omitempty"`
}

type EventOrder struct {
	Asc  *EventOrderable `json:"asc,omitempty"`
	Desc *EventOrderable `json:"desc,omitempty"`
	Then *EventOrder     `json:"then,omitempty"`
}

type EventPatch struct {
	CreatedBy *UserRef      `json:"createdBy,omitempty"`
	CreatedAt *string       `json:"createdAt,omitempty"`
	UpdatedAt *string       `json:"updatedAt,omitempty"`
	Message   *string       `json:"message,omitempty"`
	Tension   *TensionRef   `json:"tension,omitempty"`
	EventType *TensionEvent `json:"event_type,omitempty"`
	Old       *string       `json:"old,omitempty"`
	New       *string       `json:"new,omitempty"`
}

type EventRef struct {
	ID        *string       `json:"id,omitempty"`
	CreatedBy *UserRef      `json:"createdBy,omitempty"`
	CreatedAt *string       `json:"createdAt,omitempty"`
	UpdatedAt *string       `json:"updatedAt,omitempty"`
	Message   *string       `json:"message,omitempty"`
	Tension   *TensionRef   `json:"tension,omitempty"`
	EventType *TensionEvent `json:"event_type,omitempty"`
	Old       *string       `json:"old,omitempty"`
	New       *string       `json:"new,omitempty"`
}

type FloatFilter struct {
	Eq      *float64    `json:"eq,omitempty"`
	In      []*float64  `json:"in,omitempty"`
	Le      *float64    `json:"le,omitempty"`
	Lt      *float64    `json:"lt,omitempty"`
	Ge      *float64    `json:"ge,omitempty"`
	Gt      *float64    `json:"gt,omitempty"`
	Between *FloatRange `json:"between,omitempty"`
}

type FloatRange struct {
	Min float64 `json:"min,omitempty"`
	Max float64 `json:"max,omitempty"`
}

type GenerateMutationParams struct {
	Add    *bool `json:"add"`
	Update *bool `json:"update"`
	Delete *bool `json:"delete"`
}

type GenerateQueryParams struct {
	Get       *bool `json:"get"`
	Query     *bool `json:"query"`
	Password  *bool `json:"password"`
	Aggregate *bool `json:"aggregate"`
}

type Int64Filter struct {
	Eq      *string     `json:"eq,omitempty"`
	In      []*string   `json:"in,omitempty"`
	Le      *string     `json:"le,omitempty"`
	Lt      *string     `json:"lt,omitempty"`
	Ge      *string     `json:"ge,omitempty"`
	Gt      *string     `json:"gt,omitempty"`
	Between *Int64Range `json:"between,omitempty"`
}

type Int64Range struct {
	Min string `json:"min,omitempty"`
	Max string `json:"max,omitempty"`
}

type IntFilter struct {
	Eq      *int      `json:"eq,omitempty"`
	In      []*int    `json:"in,omitempty"`
	Le      *int      `json:"le,omitempty"`
	Lt      *int      `json:"lt,omitempty"`
	Ge      *int      `json:"ge,omitempty"`
	Gt      *int      `json:"gt,omitempty"`
	Between *IntRange `json:"between,omitempty"`
}

type IntRange struct {
	Min int `json:"min,omitempty"`
	Max int `json:"max,omitempty"`
}

type IntersectsFilter struct {
	Polygon      *PolygonRef      `json:"polygon,omitempty"`
	MultiPolygon *MultiPolygonRef `json:"multiPolygon,omitempty"`
}

type Label struct {
	ID          string     `json:"id,omitempty"`
	Rootnameid  string     `json:"rootnameid,omitempty"`
	Name        string     `json:"name,omitempty"`
	Description *string    `json:"description,omitempty"`
	Color       *string    `json:"color,omitempty"`
	Tensions    []*Tension `json:"tensions,omitempty"`
	Nodes       []*Node    `json:"nodes,omitempty"`
	NNodes      *int       `json:"n_nodes,omitempty"`
	NTensions   *int       `json:"n_tensions,omitempty"`
}

type LabelAggregateResult struct {
	Count          *int     `json:"count,omitempty"`
	RootnameidMin  *string  `json:"rootnameidMin,omitempty"`
	RootnameidMax  *string  `json:"rootnameidMax,omitempty"`
	NameMin        *string  `json:"nameMin,omitempty"`
	NameMax        *string  `json:"nameMax,omitempty"`
	DescriptionMin *string  `json:"descriptionMin,omitempty"`
	DescriptionMax *string  `json:"descriptionMax,omitempty"`
	ColorMin       *string  `json:"colorMin,omitempty"`
	ColorMax       *string  `json:"colorMax,omitempty"`
	NNodesMin      *int     `json:"n_nodesMin,omitempty"`
	NNodesMax      *int     `json:"n_nodesMax,omitempty"`
	NNodesSum      *int     `json:"n_nodesSum,omitempty"`
	NNodesAvg      *float64 `json:"n_nodesAvg,omitempty"`
	NTensionsMin   *int     `json:"n_tensionsMin,omitempty"`
	NTensionsMax   *int     `json:"n_tensionsMax,omitempty"`
	NTensionsSum   *int     `json:"n_tensionsSum,omitempty"`
	NTensionsAvg   *float64 `json:"n_tensionsAvg,omitempty"`
}

type LabelFilter struct {
	ID         []string                          `json:"id,omitempty"`
	Rootnameid *StringHashFilter                 `json:"rootnameid,omitempty"`
	Name       *StringHashFilterStringTermFilter `json:"name,omitempty"`
	Has        []*LabelHasFilter                 `json:"has,omitempty"`
	And        []*LabelFilter                    `json:"and,omitempty"`
	Or         []*LabelFilter                    `json:"or,omitempty"`
	Not        *LabelFilter                      `json:"not,omitempty"`
}

type LabelOrder struct {
	Asc  *LabelOrderable `json:"asc,omitempty"`
	Desc *LabelOrderable `json:"desc,omitempty"`
	Then *LabelOrder     `json:"then,omitempty"`
}

type LabelPatch struct {
	Rootnameid  *string       `json:"rootnameid,omitempty"`
	Name        *string       `json:"name,omitempty"`
	Description *string       `json:"description,omitempty"`
	Color       *string       `json:"color,omitempty"`
	Tensions    []*TensionRef `json:"tensions,omitempty"`
	Nodes       []*NodeRef    `json:"nodes,omitempty"`
	NNodes      *int          `json:"n_nodes,omitempty"`
	NTensions   *int          `json:"n_tensions,omitempty"`
}

type LabelRef struct {
	ID          *string       `json:"id,omitempty"`
	Rootnameid  *string       `json:"rootnameid,omitempty"`
	Name        *string       `json:"name,omitempty"`
	Description *string       `json:"description,omitempty"`
	Color       *string       `json:"color,omitempty"`
	Tensions    []*TensionRef `json:"tensions,omitempty"`
	Nodes       []*NodeRef    `json:"nodes,omitempty"`
	NNodes      *int          `json:"n_nodes,omitempty"`
	NTensions   *int          `json:"n_tensions,omitempty"`
}

type Mandate struct {
	ID               string  `json:"id,omitempty"`
	Purpose          string  `json:"purpose,omitempty"`
	Responsabilities *string `json:"responsabilities,omitempty"`
	Domains          *string `json:"domains,omitempty"`
	Policies         *string `json:"policies,omitempty"`
}

type MandateAggregateResult struct {
	Count               *int    `json:"count,omitempty"`
	PurposeMin          *string `json:"purposeMin,omitempty"`
	PurposeMax          *string `json:"purposeMax,omitempty"`
	ResponsabilitiesMin *string `json:"responsabilitiesMin,omitempty"`
	ResponsabilitiesMax *string `json:"responsabilitiesMax,omitempty"`
	DomainsMin          *string `json:"domainsMin,omitempty"`
	DomainsMax          *string `json:"domainsMax,omitempty"`
	PoliciesMin         *string `json:"policiesMin,omitempty"`
	PoliciesMax         *string `json:"policiesMax,omitempty"`
}

type MandateFilter struct {
	ID      []string              `json:"id,omitempty"`
	Purpose *StringFullTextFilter `json:"purpose,omitempty"`
	Has     []*MandateHasFilter   `json:"has,omitempty"`
	And     []*MandateFilter      `json:"and,omitempty"`
	Or      []*MandateFilter      `json:"or,omitempty"`
	Not     *MandateFilter        `json:"not,omitempty"`
}

type MandateOrder struct {
	Asc  *MandateOrderable `json:"asc,omitempty"`
	Desc *MandateOrderable `json:"desc,omitempty"`
	Then *MandateOrder     `json:"then,omitempty"`
}

type MandatePatch struct {
	Purpose          *string `json:"purpose,omitempty"`
	Responsabilities *string `json:"responsabilities,omitempty"`
	Domains          *string `json:"domains,omitempty"`
	Policies         *string `json:"policies,omitempty"`
}

type MandateRef struct {
	ID               *string `json:"id,omitempty"`
	Purpose          *string `json:"purpose,omitempty"`
	Responsabilities *string `json:"responsabilities,omitempty"`
	Domains          *string `json:"domains,omitempty"`
	Policies         *string `json:"policies,omitempty"`
}

type MultiPolygon struct {
	Polygons []*Polygon `json:"polygons,omitempty"`
}

type MultiPolygonRef struct {
	Polygons []*PolygonRef `json:"polygons,omitempty"`
}

type NearFilter struct {
	Distance   float64   `json:"distance,omitempty"`
	Coordinate *PointRef `json:"coordinate,omitempty"`
}

type Node struct {
	ID           string      `json:"id,omitempty"`
	CreatedBy    *User       `json:"createdBy,omitempty"`
	CreatedAt    string      `json:"createdAt,omitempty"`
	UpdatedAt    *string     `json:"updatedAt,omitempty"`
	Name         string      `json:"name,omitempty"`
	Nameid       string      `json:"nameid,omitempty"`
	Rootnameid   string      `json:"rootnameid,omitempty"`
	Parent       *Node       `json:"parent,omitempty"`
	Children     []*Node     `json:"children,omitempty"`
	Type         NodeType    `json:"type_,omitempty"`
	TensionsOut  []*Tension  `json:"tensions_out,omitempty"`
	TensionsIn   []*Tension  `json:"tensions_in,omitempty"`
	About        *string     `json:"about,omitempty"`
	Mandate      *Mandate    `json:"mandate,omitempty"`
	Docs         []*Blob     `json:"docs,omitempty"`
	Source       *Blob       `json:"source,omitempty"`
	NTensionsOut *int        `json:"n_tensions_out,omitempty"`
	NTensionsIn  *int        `json:"n_tensions_in,omitempty"`
	NChildren    *int        `json:"n_children,omitempty"`
	Stats        *NodeStats  `json:"stats,omitempty"`
	IsRoot       bool        `json:"isRoot"`
	IsPersonal   *bool       `json:"isPersonal"`
	IsPrivate    bool        `json:"isPrivate"`
	IsArchived   bool        `json:"isArchived"`
	Charac       *NodeCharac `json:"charac,omitempty"`
	Rights       int         `json:"rights,omitempty"`
	Labels       []*Label    `json:"labels,omitempty"`
	FirstLink    *User       `json:"first_link,omitempty"`
	SecondLink   *User       `json:"second_link,omitempty"`
	Skills       []string    `json:"skills,omitempty"`
	RoleType     *RoleType   `json:"role_type,omitempty"`
	Contracts    []*Vote     `json:"contracts,omitempty"`
	Shared       *SharedNode `json:"shared,omitempty"`
}

type NodeAggregateResult struct {
	Count           *int     `json:"count,omitempty"`
	CreatedAtMin    *string  `json:"createdAtMin,omitempty"`
	CreatedAtMax    *string  `json:"createdAtMax,omitempty"`
	UpdatedAtMin    *string  `json:"updatedAtMin,omitempty"`
	UpdatedAtMax    *string  `json:"updatedAtMax,omitempty"`
	NameMin         *string  `json:"nameMin,omitempty"`
	NameMax         *string  `json:"nameMax,omitempty"`
	NameidMin       *string  `json:"nameidMin,omitempty"`
	NameidMax       *string  `json:"nameidMax,omitempty"`
	RootnameidMin   *string  `json:"rootnameidMin,omitempty"`
	RootnameidMax   *string  `json:"rootnameidMax,omitempty"`
	AboutMin        *string  `json:"aboutMin,omitempty"`
	AboutMax        *string  `json:"aboutMax,omitempty"`
	NTensionsOutMin *int     `json:"n_tensions_outMin,omitempty"`
	NTensionsOutMax *int     `json:"n_tensions_outMax,omitempty"`
	NTensionsOutSum *int     `json:"n_tensions_outSum,omitempty"`
	NTensionsOutAvg *float64 `json:"n_tensions_outAvg,omitempty"`
	NTensionsInMin  *int     `json:"n_tensions_inMin,omitempty"`
	NTensionsInMax  *int     `json:"n_tensions_inMax,omitempty"`
	NTensionsInSum  *int     `json:"n_tensions_inSum,omitempty"`
	NTensionsInAvg  *float64 `json:"n_tensions_inAvg,omitempty"`
	NChildrenMin    *int     `json:"n_childrenMin,omitempty"`
	NChildrenMax    *int     `json:"n_childrenMax,omitempty"`
	NChildrenSum    *int     `json:"n_childrenSum,omitempty"`
	NChildrenAvg    *float64 `json:"n_childrenAvg,omitempty"`
	RightsMin       *int     `json:"rightsMin,omitempty"`
	RightsMax       *int     `json:"rightsMax,omitempty"`
	RightsSum       *int     `json:"rightsSum,omitempty"`
	RightsAvg       *float64 `json:"rightsAvg,omitempty"`
}

type NodeCharac struct {
	ID          string   `json:"id,omitempty"`
	UserCanJoin bool     `json:"userCanJoin"`
	Mode        NodeMode `json:"mode,omitempty"`
}

type NodeCharacAggregateResult struct {
	Count *int `json:"count,omitempty"`
}

type NodeCharacFilter struct {
	ID          []string               `json:"id,omitempty"`
	UserCanJoin *bool                  `json:"userCanJoin"`
	Mode        *NodeModeHash          `json:"mode,omitempty"`
	Has         []*NodeCharacHasFilter `json:"has,omitempty"`
	And         []*NodeCharacFilter    `json:"and,omitempty"`
	Or          []*NodeCharacFilter    `json:"or,omitempty"`
	Not         *NodeCharacFilter      `json:"not,omitempty"`
}

type NodeCharacPatch struct {
	UserCanJoin *bool     `json:"userCanJoin"`
	Mode        *NodeMode `json:"mode,omitempty"`
}

type NodeCharacRef struct {
	ID          *string   `json:"id,omitempty"`
	UserCanJoin *bool     `json:"userCanJoin"`
	Mode        *NodeMode `json:"mode,omitempty"`
}

type NodeFilter struct {
	ID         []string                            `json:"id,omitempty"`
	CreatedAt  *DateTimeFilter                     `json:"createdAt,omitempty"`
	Name       *StringTermFilter                   `json:"name,omitempty"`
	Nameid     *StringHashFilterStringRegExpFilter `json:"nameid,omitempty"`
	Rootnameid *StringHashFilterStringRegExpFilter `json:"rootnameid,omitempty"`
	Type       *NodeTypeHash                       `json:"type_,omitempty"`
	About      *StringFullTextFilter               `json:"about,omitempty"`
	IsRoot     *bool                               `json:"isRoot"`
	IsPersonal *bool                               `json:"isPersonal"`
	IsPrivate  *bool                               `json:"isPrivate"`
	IsArchived *bool                               `json:"isArchived"`
	Skills     *StringTermFilter                   `json:"skills,omitempty"`
	RoleType   *RoleTypeHash                       `json:"role_type,omitempty"`
	Has        []*NodeHasFilter                    `json:"has,omitempty"`
	And        []*NodeFilter                       `json:"and,omitempty"`
	Or         []*NodeFilter                       `json:"or,omitempty"`
	Not        *NodeFilter                         `json:"not,omitempty"`
}

type NodeFragment struct {
	ID         string          `json:"id,omitempty"`
	Name       *string         `json:"name,omitempty"`
	Nameid     *string         `json:"nameid,omitempty"`
	Type       *NodeType       `json:"type_,omitempty"`
	IsPrivate  *bool           `json:"isPrivate"`
	Charac     *NodeCharac     `json:"charac,omitempty"`
	About      *string         `json:"about,omitempty"`
	Mandate    *Mandate        `json:"mandate,omitempty"`
	Children   []*NodeFragment `json:"children,omitempty"`
	FirstLink  *string         `json:"first_link,omitempty"`
	SecondLink *string         `json:"second_link,omitempty"`
	Skills     []string        `json:"skills,omitempty"`
	RoleType   *RoleType       `json:"role_type,omitempty"`
}

type NodeFragmentAggregateResult struct {
	Count         *int    `json:"count,omitempty"`
	NameMin       *string `json:"nameMin,omitempty"`
	NameMax       *string `json:"nameMax,omitempty"`
	NameidMin     *string `json:"nameidMin,omitempty"`
	NameidMax     *string `json:"nameidMax,omitempty"`
	AboutMin      *string `json:"aboutMin,omitempty"`
	AboutMax      *string `json:"aboutMax,omitempty"`
	FirstLinkMin  *string `json:"first_linkMin,omitempty"`
	FirstLinkMax  *string `json:"first_linkMax,omitempty"`
	SecondLinkMin *string `json:"second_linkMin,omitempty"`
	SecondLinkMax *string `json:"second_linkMax,omitempty"`
}

type NodeFragmentFilter struct {
	ID  []string                 `json:"id,omitempty"`
	Has []*NodeFragmentHasFilter `json:"has,omitempty"`
	And []*NodeFragmentFilter    `json:"and,omitempty"`
	Or  []*NodeFragmentFilter    `json:"or,omitempty"`
	Not *NodeFragmentFilter      `json:"not,omitempty"`
}

type NodeFragmentOrder struct {
	Asc  *NodeFragmentOrderable `json:"asc,omitempty"`
	Desc *NodeFragmentOrderable `json:"desc,omitempty"`
	Then *NodeFragmentOrder     `json:"then,omitempty"`
}

type NodeFragmentPatch struct {
	Name       *string            `json:"name,omitempty"`
	Nameid     *string            `json:"nameid,omitempty"`
	Type       *NodeType          `json:"type_,omitempty"`
	IsPrivate  *bool              `json:"isPrivate"`
	Charac     *NodeCharacRef     `json:"charac,omitempty"`
	About      *string            `json:"about,omitempty"`
	Mandate    *MandateRef        `json:"mandate,omitempty"`
	Children   []*NodeFragmentRef `json:"children,omitempty"`
	FirstLink  *string            `json:"first_link,omitempty"`
	SecondLink *string            `json:"second_link,omitempty"`
	Skills     []string           `json:"skills,omitempty"`
	RoleType   *RoleType          `json:"role_type,omitempty"`
}

type NodeFragmentRef struct {
	ID         *string            `json:"id,omitempty"`
	Name       *string            `json:"name,omitempty"`
	Nameid     *string            `json:"nameid,omitempty"`
	Type       *NodeType          `json:"type_,omitempty"`
	IsPrivate  *bool              `json:"isPrivate"`
	Charac     *NodeCharacRef     `json:"charac,omitempty"`
	About      *string            `json:"about,omitempty"`
	Mandate    *MandateRef        `json:"mandate,omitempty"`
	Children   []*NodeFragmentRef `json:"children,omitempty"`
	FirstLink  *string            `json:"first_link,omitempty"`
	SecondLink *string            `json:"second_link,omitempty"`
	Skills     []string           `json:"skills,omitempty"`
	RoleType   *RoleType          `json:"role_type,omitempty"`
}

type NodeModeHash struct {
	Eq *NodeMode   `json:"eq,omitempty"`
	In []*NodeMode `json:"in,omitempty"`
}

type NodeOrder struct {
	Asc  *NodeOrderable `json:"asc,omitempty"`
	Desc *NodeOrderable `json:"desc,omitempty"`
	Then *NodeOrder     `json:"then,omitempty"`
}

type NodePatch struct {
	CreatedBy    *UserRef       `json:"createdBy,omitempty"`
	CreatedAt    *string        `json:"createdAt,omitempty"`
	UpdatedAt    *string        `json:"updatedAt,omitempty"`
	Name         *string        `json:"name,omitempty"`
	Rootnameid   *string        `json:"rootnameid,omitempty"`
	Parent       *NodeRef       `json:"parent,omitempty"`
	Children     []*NodeRef     `json:"children,omitempty"`
	Type         *NodeType      `json:"type_,omitempty"`
	TensionsOut  []*TensionRef  `json:"tensions_out,omitempty"`
	TensionsIn   []*TensionRef  `json:"tensions_in,omitempty"`
	About        *string        `json:"about,omitempty"`
	Mandate      *MandateRef    `json:"mandate,omitempty"`
	Docs         []*BlobRef     `json:"docs,omitempty"`
	Source       *BlobRef       `json:"source,omitempty"`
	NTensionsOut *int           `json:"n_tensions_out,omitempty"`
	NTensionsIn  *int           `json:"n_tensions_in,omitempty"`
	NChildren    *int           `json:"n_children,omitempty"`
	Stats        *NodeStatsRef  `json:"stats,omitempty"`
	IsRoot       *bool          `json:"isRoot"`
	IsPersonal   *bool          `json:"isPersonal"`
	IsPrivate    *bool          `json:"isPrivate"`
	IsArchived   *bool          `json:"isArchived"`
	Charac       *NodeCharacRef `json:"charac,omitempty"`
	Rights       *int           `json:"rights,omitempty"`
	Labels       []*LabelRef    `json:"labels,omitempty"`
	FirstLink    *UserRef       `json:"first_link,omitempty"`
	SecondLink   *UserRef       `json:"second_link,omitempty"`
	Skills       []string       `json:"skills,omitempty"`
	RoleType     *RoleType      `json:"role_type,omitempty"`
	Contracts    []*VoteRef     `json:"contracts,omitempty"`
	Shared       *SharedNodeRef `json:"shared,omitempty"`
}

type NodeRef struct {
	ID           *string        `json:"id,omitempty"`
	CreatedBy    *UserRef       `json:"createdBy,omitempty"`
	CreatedAt    *string        `json:"createdAt,omitempty"`
	UpdatedAt    *string        `json:"updatedAt,omitempty"`
	Name         *string        `json:"name,omitempty"`
	Nameid       *string        `json:"nameid,omitempty"`
	Rootnameid   *string        `json:"rootnameid,omitempty"`
	Parent       *NodeRef       `json:"parent,omitempty"`
	Children     []*NodeRef     `json:"children,omitempty"`
	Type         *NodeType      `json:"type_,omitempty"`
	TensionsOut  []*TensionRef  `json:"tensions_out,omitempty"`
	TensionsIn   []*TensionRef  `json:"tensions_in,omitempty"`
	About        *string        `json:"about,omitempty"`
	Mandate      *MandateRef    `json:"mandate,omitempty"`
	Docs         []*BlobRef     `json:"docs,omitempty"`
	Source       *BlobRef       `json:"source,omitempty"`
	NTensionsOut *int           `json:"n_tensions_out,omitempty"`
	NTensionsIn  *int           `json:"n_tensions_in,omitempty"`
	NChildren    *int           `json:"n_children,omitempty"`
	Stats        *NodeStatsRef  `json:"stats,omitempty"`
	IsRoot       *bool          `json:"isRoot"`
	IsPersonal   *bool          `json:"isPersonal"`
	IsPrivate    *bool          `json:"isPrivate"`
	IsArchived   *bool          `json:"isArchived"`
	Charac       *NodeCharacRef `json:"charac,omitempty"`
	Rights       *int           `json:"rights,omitempty"`
	Labels       []*LabelRef    `json:"labels,omitempty"`
	FirstLink    *UserRef       `json:"first_link,omitempty"`
	SecondLink   *UserRef       `json:"second_link,omitempty"`
	Skills       []string       `json:"skills,omitempty"`
	RoleType     *RoleType      `json:"role_type,omitempty"`
	Contracts    []*VoteRef     `json:"contracts,omitempty"`
	Shared       *SharedNodeRef `json:"shared,omitempty"`
}

type NodeStats struct {
	NMember *int `json:"n_member,omitempty"`
	NGuest  *int `json:"n_guest,omitempty"`
	NCircle *int `json:"n_circle,omitempty"`
	NRole   *int `json:"n_role,omitempty"`
}

type NodeStatsAggregateResult struct {
	Count      *int     `json:"count,omitempty"`
	NMemberMin *int     `json:"n_memberMin,omitempty"`
	NMemberMax *int     `json:"n_memberMax,omitempty"`
	NMemberSum *int     `json:"n_memberSum,omitempty"`
	NMemberAvg *float64 `json:"n_memberAvg,omitempty"`
	NGuestMin  *int     `json:"n_guestMin,omitempty"`
	NGuestMax  *int     `json:"n_guestMax,omitempty"`
	NGuestSum  *int     `json:"n_guestSum,omitempty"`
	NGuestAvg  *float64 `json:"n_guestAvg,omitempty"`
	NCircleMin *int     `json:"n_circleMin,omitempty"`
	NCircleMax *int     `json:"n_circleMax,omitempty"`
	NCircleSum *int     `json:"n_circleSum,omitempty"`
	NCircleAvg *float64 `json:"n_circleAvg,omitempty"`
	NRoleMin   *int     `json:"n_roleMin,omitempty"`
	NRoleMax   *int     `json:"n_roleMax,omitempty"`
	NRoleSum   *int     `json:"n_roleSum,omitempty"`
	NRoleAvg   *float64 `json:"n_roleAvg,omitempty"`
}

type NodeStatsFilter struct {
	Has []*NodeStatsHasFilter `json:"has,omitempty"`
	And []*NodeStatsFilter    `json:"and,omitempty"`
	Or  []*NodeStatsFilter    `json:"or,omitempty"`
	Not *NodeStatsFilter      `json:"not,omitempty"`
}

type NodeStatsOrder struct {
	Asc  *NodeStatsOrderable `json:"asc,omitempty"`
	Desc *NodeStatsOrderable `json:"desc,omitempty"`
	Then *NodeStatsOrder     `json:"then,omitempty"`
}

type NodeStatsPatch struct {
	NMember *int `json:"n_member,omitempty"`
	NGuest  *int `json:"n_guest,omitempty"`
	NCircle *int `json:"n_circle,omitempty"`
	NRole   *int `json:"n_role,omitempty"`
}

type NodeStatsRef struct {
	NMember *int `json:"n_member,omitempty"`
	NGuest  *int `json:"n_guest,omitempty"`
	NCircle *int `json:"n_circle,omitempty"`
	NRole   *int `json:"n_role,omitempty"`
}

type NodeTypeHash struct {
	Eq *NodeType   `json:"eq,omitempty"`
	In []*NodeType `json:"in,omitempty"`
}

type Point struct {
	Longitude float64 `json:"longitude,omitempty"`
	Latitude  float64 `json:"latitude,omitempty"`
}

type PointGeoFilter struct {
	Near   *NearFilter   `json:"near,omitempty"`
	Within *WithinFilter `json:"within,omitempty"`
}

type PointList struct {
	Points []*Point `json:"points,omitempty"`
}

type PointListRef struct {
	Points []*PointRef `json:"points,omitempty"`
}

type PointRef struct {
	Longitude float64 `json:"longitude,omitempty"`
	Latitude  float64 `json:"latitude,omitempty"`
}

type Polygon struct {
	Coordinates []*PointList `json:"coordinates,omitempty"`
}

type PolygonGeoFilter struct {
	Near       *NearFilter       `json:"near,omitempty"`
	Within     *WithinFilter     `json:"within,omitempty"`
	Contains   *ContainsFilter   `json:"contains,omitempty"`
	Intersects *IntersectsFilter `json:"intersects,omitempty"`
}

type PolygonRef struct {
	Coordinates []*PointListRef `json:"coordinates,omitempty"`
}

type Post struct {
	ID        string  `json:"id,omitempty"`
	CreatedBy *User   `json:"createdBy,omitempty"`
	CreatedAt string  `json:"createdAt,omitempty"`
	UpdatedAt *string `json:"updatedAt,omitempty"`
	Message   *string `json:"message,omitempty"`
}

type PostAggregateResult struct {
	Count        *int    `json:"count,omitempty"`
	CreatedAtMin *string `json:"createdAtMin,omitempty"`
	CreatedAtMax *string `json:"createdAtMax,omitempty"`
	UpdatedAtMin *string `json:"updatedAtMin,omitempty"`
	UpdatedAtMax *string `json:"updatedAtMax,omitempty"`
	MessageMin   *string `json:"messageMin,omitempty"`
	MessageMax   *string `json:"messageMax,omitempty"`
}

type PostFilter struct {
	ID        []string              `json:"id,omitempty"`
	CreatedAt *DateTimeFilter       `json:"createdAt,omitempty"`
	Message   *StringFullTextFilter `json:"message,omitempty"`
	Has       []*PostHasFilter      `json:"has,omitempty"`
	And       []*PostFilter         `json:"and,omitempty"`
	Or        []*PostFilter         `json:"or,omitempty"`
	Not       *PostFilter           `json:"not,omitempty"`
}

type PostOrder struct {
	Asc  *PostOrderable `json:"asc,omitempty"`
	Desc *PostOrderable `json:"desc,omitempty"`
	Then *PostOrder     `json:"then,omitempty"`
}

type PostPatch struct {
	CreatedBy *UserRef `json:"createdBy,omitempty"`
	CreatedAt *string  `json:"createdAt,omitempty"`
	UpdatedAt *string  `json:"updatedAt,omitempty"`
	Message   *string  `json:"message,omitempty"`
}

type PostRef struct {
	ID string `json:"id,omitempty"`
}

type RoleTypeHash struct {
	Eq *RoleType   `json:"eq,omitempty"`
	In []*RoleType `json:"in,omitempty"`
}

type SharedNode struct {
	NLabels         *int `json:"n_labels,omitempty"`
	NTensions       *int `json:"n_tensions,omitempty"`
	NClosedTensions *int `json:"n_closed_tensions,omitempty"`
}

type SharedNodeAggregateResult struct {
	Count              *int     `json:"count,omitempty"`
	NLabelsMin         *int     `json:"n_labelsMin,omitempty"`
	NLabelsMax         *int     `json:"n_labelsMax,omitempty"`
	NLabelsSum         *int     `json:"n_labelsSum,omitempty"`
	NLabelsAvg         *float64 `json:"n_labelsAvg,omitempty"`
	NTensionsMin       *int     `json:"n_tensionsMin,omitempty"`
	NTensionsMax       *int     `json:"n_tensionsMax,omitempty"`
	NTensionsSum       *int     `json:"n_tensionsSum,omitempty"`
	NTensionsAvg       *float64 `json:"n_tensionsAvg,omitempty"`
	NClosedTensionsMin *int     `json:"n_closed_tensionsMin,omitempty"`
	NClosedTensionsMax *int     `json:"n_closed_tensionsMax,omitempty"`
	NClosedTensionsSum *int     `json:"n_closed_tensionsSum,omitempty"`
	NClosedTensionsAvg *float64 `json:"n_closed_tensionsAvg,omitempty"`
}

type SharedNodeFilter struct {
	Has []*SharedNodeHasFilter `json:"has,omitempty"`
	And []*SharedNodeFilter    `json:"and,omitempty"`
	Or  []*SharedNodeFilter    `json:"or,omitempty"`
	Not *SharedNodeFilter      `json:"not,omitempty"`
}

type SharedNodeOrder struct {
	Asc  *SharedNodeOrderable `json:"asc,omitempty"`
	Desc *SharedNodeOrderable `json:"desc,omitempty"`
	Then *SharedNodeOrder     `json:"then,omitempty"`
}

type SharedNodePatch struct {
	NLabels         *int `json:"n_labels,omitempty"`
	NTensions       *int `json:"n_tensions,omitempty"`
	NClosedTensions *int `json:"n_closed_tensions,omitempty"`
}

type SharedNodeRef struct {
	NLabels         *int `json:"n_labels,omitempty"`
	NTensions       *int `json:"n_tensions,omitempty"`
	NClosedTensions *int `json:"n_closed_tensions,omitempty"`
}

type StringExactFilter struct {
	Eq      *string      `json:"eq,omitempty"`
	In      []*string    `json:"in,omitempty"`
	Le      *string      `json:"le,omitempty"`
	Lt      *string      `json:"lt,omitempty"`
	Ge      *string      `json:"ge,omitempty"`
	Gt      *string      `json:"gt,omitempty"`
	Between *StringRange `json:"between,omitempty"`
}

type StringFullTextFilter struct {
	Alloftext *string `json:"alloftext,omitempty"`
	Anyoftext *string `json:"anyoftext,omitempty"`
}

type StringHashFilter struct {
	Eq *string   `json:"eq,omitempty"`
	In []*string `json:"in,omitempty"`
}

type StringHashFilterStringRegExpFilter struct {
	Eq     *string   `json:"eq,omitempty"`
	In     []*string `json:"in,omitempty"`
	Regexp *string   `json:"regexp,omitempty"`
}

type StringHashFilterStringTermFilter struct {
	Eq         *string   `json:"eq,omitempty"`
	In         []*string `json:"in,omitempty"`
	Allofterms *string   `json:"allofterms,omitempty"`
	Anyofterms *string   `json:"anyofterms,omitempty"`
}

type StringRange struct {
	Min string `json:"min,omitempty"`
	Max string `json:"max,omitempty"`
}

type StringRegExpFilter struct {
	Regexp *string `json:"regexp,omitempty"`
}

type StringTermFilter struct {
	Allofterms *string `json:"allofterms,omitempty"`
	Anyofterms *string `json:"anyofterms,omitempty"`
}

type Tension struct {
	Emitterid  string         `json:"emitterid,omitempty"`
	Emitter    *Node          `json:"emitter,omitempty"`
	Receiverid string         `json:"receiverid,omitempty"`
	Receiver   *Node          `json:"receiver,omitempty"`
	Nth        *string        `json:"nth,omitempty"`
	Title      string         `json:"title,omitempty"`
	Type       TensionType    `json:"type_,omitempty"`
	Status     TensionStatus  `json:"status,omitempty"`
	Assignees  []*User        `json:"assignees,omitempty"`
	Labels     []*Label       `json:"labels,omitempty"`
	Comments   []*Comment     `json:"comments,omitempty"`
	Action     *TensionAction `json:"action,omitempty"`
	Blobs      []*Blob        `json:"blobs,omitempty"`
	Contracts  []*Contract    `json:"contracts,omitempty"`
	History    []*Event       `json:"history,omitempty"`
	NComments  *int           `json:"n_comments,omitempty"`
	NBlobs     *int           `json:"n_blobs,omitempty"`
	ID         string         `json:"id,omitempty"`
	CreatedBy  *User          `json:"createdBy,omitempty"`
	CreatedAt  string         `json:"createdAt,omitempty"`
	UpdatedAt  *string        `json:"updatedAt,omitempty"`
	Message    *string        `json:"message,omitempty"`
}

type TensionAggregateResult struct {
	Count         *int     `json:"count,omitempty"`
	CreatedAtMin  *string  `json:"createdAtMin,omitempty"`
	CreatedAtMax  *string  `json:"createdAtMax,omitempty"`
	UpdatedAtMin  *string  `json:"updatedAtMin,omitempty"`
	UpdatedAtMax  *string  `json:"updatedAtMax,omitempty"`
	MessageMin    *string  `json:"messageMin,omitempty"`
	MessageMax    *string  `json:"messageMax,omitempty"`
	EmitteridMin  *string  `json:"emitteridMin,omitempty"`
	EmitteridMax  *string  `json:"emitteridMax,omitempty"`
	ReceiveridMin *string  `json:"receiveridMin,omitempty"`
	ReceiveridMax *string  `json:"receiveridMax,omitempty"`
	NthMin        *string  `json:"nthMin,omitempty"`
	NthMax        *string  `json:"nthMax,omitempty"`
	TitleMin      *string  `json:"titleMin,omitempty"`
	TitleMax      *string  `json:"titleMax,omitempty"`
	NCommentsMin  *int     `json:"n_commentsMin,omitempty"`
	NCommentsMax  *int     `json:"n_commentsMax,omitempty"`
	NCommentsSum  *int     `json:"n_commentsSum,omitempty"`
	NCommentsAvg  *float64 `json:"n_commentsAvg,omitempty"`
	NBlobsMin     *int     `json:"n_blobsMin,omitempty"`
	NBlobsMax     *int     `json:"n_blobsMax,omitempty"`
	NBlobsSum     *int     `json:"n_blobsSum,omitempty"`
	NBlobsAvg     *float64 `json:"n_blobsAvg,omitempty"`
}

type TensionEventHash struct {
	Eq *TensionEvent   `json:"eq,omitempty"`
	In []*TensionEvent `json:"in,omitempty"`
}

type TensionFilter struct {
	ID         []string                            `json:"id,omitempty"`
	CreatedAt  *DateTimeFilter                     `json:"createdAt,omitempty"`
	Message    *StringFullTextFilter               `json:"message,omitempty"`
	Emitterid  *StringHashFilterStringRegExpFilter `json:"emitterid,omitempty"`
	Receiverid *StringHashFilterStringRegExpFilter `json:"receiverid,omitempty"`
	Nth        *StringTermFilter                   `json:"nth,omitempty"`
	Title      *StringFullTextFilter               `json:"title,omitempty"`
	Type       *TensionTypeHash                    `json:"type_,omitempty"`
	Status     *TensionStatusHash                  `json:"status,omitempty"`
	Has        []*TensionHasFilter                 `json:"has,omitempty"`
	And        []*TensionFilter                    `json:"and,omitempty"`
	Or         []*TensionFilter                    `json:"or,omitempty"`
	Not        *TensionFilter                      `json:"not,omitempty"`
}

type TensionOrder struct {
	Asc  *TensionOrderable `json:"asc,omitempty"`
	Desc *TensionOrderable `json:"desc,omitempty"`
	Then *TensionOrder     `json:"then,omitempty"`
}

type TensionPatch struct {
	CreatedBy  *UserRef       `json:"createdBy,omitempty"`
	CreatedAt  *string        `json:"createdAt,omitempty"`
	UpdatedAt  *string        `json:"updatedAt,omitempty"`
	Message    *string        `json:"message,omitempty"`
	Emitterid  *string        `json:"emitterid,omitempty"`
	Emitter    *NodeRef       `json:"emitter,omitempty"`
	Receiverid *string        `json:"receiverid,omitempty"`
	Receiver   *NodeRef       `json:"receiver,omitempty"`
	Nth        *string        `json:"nth,omitempty"`
	Title      *string        `json:"title,omitempty"`
	Type       *TensionType   `json:"type_,omitempty"`
	Status     *TensionStatus `json:"status,omitempty"`
	Assignees  []*UserRef     `json:"assignees,omitempty"`
	Labels     []*LabelRef    `json:"labels,omitempty"`
	Comments   []*CommentRef  `json:"comments,omitempty"`
	Action     *TensionAction `json:"action,omitempty"`
	Blobs      []*BlobRef     `json:"blobs,omitempty"`
	Contracts  []*ContractRef `json:"contracts,omitempty"`
	History    []*EventRef    `json:"history,omitempty"`
	NComments  *int           `json:"n_comments,omitempty"`
	NBlobs     *int           `json:"n_blobs,omitempty"`
}

type TensionRef struct {
	ID         *string        `json:"id,omitempty"`
	CreatedBy  *UserRef       `json:"createdBy,omitempty"`
	CreatedAt  *string        `json:"createdAt,omitempty"`
	UpdatedAt  *string        `json:"updatedAt,omitempty"`
	Message    *string        `json:"message,omitempty"`
	Emitterid  *string        `json:"emitterid,omitempty"`
	Emitter    *NodeRef       `json:"emitter,omitempty"`
	Receiverid *string        `json:"receiverid,omitempty"`
	Receiver   *NodeRef       `json:"receiver,omitempty"`
	Nth        *string        `json:"nth,omitempty"`
	Title      *string        `json:"title,omitempty"`
	Type       *TensionType   `json:"type_,omitempty"`
	Status     *TensionStatus `json:"status,omitempty"`
	Assignees  []*UserRef     `json:"assignees,omitempty"`
	Labels     []*LabelRef    `json:"labels,omitempty"`
	Comments   []*CommentRef  `json:"comments,omitempty"`
	Action     *TensionAction `json:"action,omitempty"`
	Blobs      []*BlobRef     `json:"blobs,omitempty"`
	Contracts  []*ContractRef `json:"contracts,omitempty"`
	History    []*EventRef    `json:"history,omitempty"`
	NComments  *int           `json:"n_comments,omitempty"`
	NBlobs     *int           `json:"n_blobs,omitempty"`
}

type TensionStatusHash struct {
	Eq *TensionStatus   `json:"eq,omitempty"`
	In []*TensionStatus `json:"in,omitempty"`
}

type TensionTypeHash struct {
	Eq *TensionType   `json:"eq,omitempty"`
	In []*TensionType `json:"in,omitempty"`
}

type UpdateBlobInput struct {
	Filter *BlobFilter `json:"filter,omitempty"`
	Set    *BlobPatch  `json:"set,omitempty"`
	Remove *BlobPatch  `json:"remove,omitempty"`
}

type UpdateBlobPayload struct {
	Blob    []*Blob `json:"blob,omitempty"`
	NumUids *int    `json:"numUids,omitempty"`
}

type UpdateCommentInput struct {
	Filter *CommentFilter `json:"filter,omitempty"`
	Set    *CommentPatch  `json:"set,omitempty"`
	Remove *CommentPatch  `json:"remove,omitempty"`
}

type UpdateCommentPayload struct {
	Comment []*Comment `json:"comment,omitempty"`
	NumUids *int       `json:"numUids,omitempty"`
}

type UpdateContractInput struct {
	Filter *ContractFilter `json:"filter,omitempty"`
	Set    *ContractPatch  `json:"set,omitempty"`
	Remove *ContractPatch  `json:"remove,omitempty"`
}

type UpdateContractPayload struct {
	Contract []*Contract `json:"contract,omitempty"`
	NumUids  *int        `json:"numUids,omitempty"`
}

type UpdateEventFragmentInput struct {
	Filter *EventFragmentFilter `json:"filter,omitempty"`
	Set    *EventFragmentPatch  `json:"set,omitempty"`
	Remove *EventFragmentPatch  `json:"remove,omitempty"`
}

type UpdateEventFragmentPayload struct {
	EventFragment []*EventFragment `json:"eventFragment,omitempty"`
	NumUids       *int             `json:"numUids,omitempty"`
}

type UpdateEventInput struct {
	Filter *EventFilter `json:"filter,omitempty"`
	Set    *EventPatch  `json:"set,omitempty"`
	Remove *EventPatch  `json:"remove,omitempty"`
}

type UpdateEventPayload struct {
	Event   []*Event `json:"event,omitempty"`
	NumUids *int     `json:"numUids,omitempty"`
}

type UpdateLabelInput struct {
	Filter *LabelFilter `json:"filter,omitempty"`
	Set    *LabelPatch  `json:"set,omitempty"`
	Remove *LabelPatch  `json:"remove,omitempty"`
}

type UpdateLabelPayload struct {
	Label   []*Label `json:"label,omitempty"`
	NumUids *int     `json:"numUids,omitempty"`
}

type UpdateMandateInput struct {
	Filter *MandateFilter `json:"filter,omitempty"`
	Set    *MandatePatch  `json:"set,omitempty"`
	Remove *MandatePatch  `json:"remove,omitempty"`
}

type UpdateMandatePayload struct {
	Mandate []*Mandate `json:"mandate,omitempty"`
	NumUids *int       `json:"numUids,omitempty"`
}

type UpdateNodeCharacInput struct {
	Filter *NodeCharacFilter `json:"filter,omitempty"`
	Set    *NodeCharacPatch  `json:"set,omitempty"`
	Remove *NodeCharacPatch  `json:"remove,omitempty"`
}

type UpdateNodeCharacPayload struct {
	NodeCharac []*NodeCharac `json:"nodeCharac,omitempty"`
	NumUids    *int          `json:"numUids,omitempty"`
}

type UpdateNodeFragmentInput struct {
	Filter *NodeFragmentFilter `json:"filter,omitempty"`
	Set    *NodeFragmentPatch  `json:"set,omitempty"`
	Remove *NodeFragmentPatch  `json:"remove,omitempty"`
}

type UpdateNodeFragmentPayload struct {
	NodeFragment []*NodeFragment `json:"nodeFragment,omitempty"`
	NumUids      *int            `json:"numUids,omitempty"`
}

type UpdateNodeInput struct {
	Filter *NodeFilter `json:"filter,omitempty"`
	Set    *NodePatch  `json:"set,omitempty"`
	Remove *NodePatch  `json:"remove,omitempty"`
}

type UpdateNodePayload struct {
	Node    []*Node `json:"node,omitempty"`
	NumUids *int    `json:"numUids,omitempty"`
}

type UpdateNodeStatsInput struct {
	Filter *NodeStatsFilter `json:"filter,omitempty"`
	Set    *NodeStatsPatch  `json:"set,omitempty"`
	Remove *NodeStatsPatch  `json:"remove,omitempty"`
}

type UpdateNodeStatsPayload struct {
	NodeStats []*NodeStats `json:"nodeStats,omitempty"`
	NumUids   *int         `json:"numUids,omitempty"`
}

type UpdatePostInput struct {
	Filter *PostFilter `json:"filter,omitempty"`
	Set    *PostPatch  `json:"set,omitempty"`
	Remove *PostPatch  `json:"remove,omitempty"`
}

type UpdatePostPayload struct {
	Post    []*Post `json:"post,omitempty"`
	NumUids *int    `json:"numUids,omitempty"`
}

type UpdateSharedNodeInput struct {
	Filter *SharedNodeFilter `json:"filter,omitempty"`
	Set    *SharedNodePatch  `json:"set,omitempty"`
	Remove *SharedNodePatch  `json:"remove,omitempty"`
}

type UpdateSharedNodePayload struct {
	SharedNode []*SharedNode `json:"sharedNode,omitempty"`
	NumUids    *int          `json:"numUids,omitempty"`
}

type UpdateTensionInput struct {
	Filter *TensionFilter `json:"filter,omitempty"`
	Set    *TensionPatch  `json:"set,omitempty"`
	Remove *TensionPatch  `json:"remove,omitempty"`
}

type UpdateTensionPayload struct {
	Tension []*Tension `json:"tension,omitempty"`
	NumUids *int       `json:"numUids,omitempty"`
}

type UpdateUserInput struct {
	Filter *UserFilter `json:"filter,omitempty"`
	Set    *UserPatch  `json:"set,omitempty"`
	Remove *UserPatch  `json:"remove,omitempty"`
}

type UpdateUserPayload struct {
	User    []*User `json:"user,omitempty"`
	NumUids *int    `json:"numUids,omitempty"`
}

type UpdateUserRightsInput struct {
	Filter *UserRightsFilter `json:"filter,omitempty"`
	Set    *UserRightsPatch  `json:"set,omitempty"`
	Remove *UserRightsPatch  `json:"remove,omitempty"`
}

type UpdateUserRightsPayload struct {
	UserRights []*UserRights `json:"userRights,omitempty"`
	NumUids    *int          `json:"numUids,omitempty"`
}

type UpdateVoteInput struct {
	Filter *VoteFilter `json:"filter,omitempty"`
	Set    *VotePatch  `json:"set,omitempty"`
	Remove *VotePatch  `json:"remove,omitempty"`
}

type UpdateVotePayload struct {
	Vote    []*Vote `json:"vote,omitempty"`
	NumUids *int    `json:"numUids,omitempty"`
}

type User struct {
	ID               string      `json:"id,omitempty"`
	CreatedAt        string      `json:"createdAt,omitempty"`
	LastAck          string      `json:"lastAck,omitempty"`
	Username         string      `json:"username,omitempty"`
	Name             *string     `json:"name,omitempty"`
	Password         string      `json:"password,omitempty"`
	Email            string      `json:"email,omitempty"`
	EmailHash        *string     `json:"emailHash,omitempty"`
	EmailValidated   bool        `json:"emailValidated"`
	Rights           *UserRights `json:"rights,omitempty"`
	Roles            []*Node     `json:"roles,omitempty"`
	BackedRoles      []*Node     `json:"backed_roles,omitempty"`
	TensionsCreated  []*Tension  `json:"tensions_created,omitempty"`
	TensionsAssigned []*Tension  `json:"tensions_assigned,omitempty"`
	Contracts        []*Contract `json:"contracts,omitempty"`
	Bio              *string     `json:"bio,omitempty"`
	Utc              *string     `json:"utc,omitempty"`
}

type UserAggregateResult struct {
	Count        *int    `json:"count,omitempty"`
	CreatedAtMin *string `json:"createdAtMin,omitempty"`
	CreatedAtMax *string `json:"createdAtMax,omitempty"`
	LastAckMin   *string `json:"lastAckMin,omitempty"`
	LastAckMax   *string `json:"lastAckMax,omitempty"`
	UsernameMin  *string `json:"usernameMin,omitempty"`
	UsernameMax  *string `json:"usernameMax,omitempty"`
	NameMin      *string `json:"nameMin,omitempty"`
	NameMax      *string `json:"nameMax,omitempty"`
	PasswordMin  *string `json:"passwordMin,omitempty"`
	PasswordMax  *string `json:"passwordMax,omitempty"`
	EmailMin     *string `json:"emailMin,omitempty"`
	EmailMax     *string `json:"emailMax,omitempty"`
	EmailHashMin *string `json:"emailHashMin,omitempty"`
	EmailHashMax *string `json:"emailHashMax,omitempty"`
	BioMin       *string `json:"bioMin,omitempty"`
	BioMax       *string `json:"bioMax,omitempty"`
	UtcMin       *string `json:"utcMin,omitempty"`
	UtcMax       *string `json:"utcMax,omitempty"`
}

type UserFilter struct {
	ID       []string          `json:"id,omitempty"`
	Username *StringHashFilter `json:"username,omitempty"`
	Email    *StringHashFilter `json:"email,omitempty"`
	Has      []*UserHasFilter  `json:"has,omitempty"`
	And      []*UserFilter     `json:"and,omitempty"`
	Or       []*UserFilter     `json:"or,omitempty"`
	Not      *UserFilter       `json:"not,omitempty"`
}

type UserOrder struct {
	Asc  *UserOrderable `json:"asc,omitempty"`
	Desc *UserOrderable `json:"desc,omitempty"`
	Then *UserOrder     `json:"then,omitempty"`
}

type UserPatch struct {
	CreatedAt        *string        `json:"createdAt,omitempty"`
	LastAck          *string        `json:"lastAck,omitempty"`
	Name             *string        `json:"name,omitempty"`
	Password         *string        `json:"password,omitempty"`
	Email            *string        `json:"email,omitempty"`
	EmailHash        *string        `json:"emailHash,omitempty"`
	EmailValidated   *bool          `json:"emailValidated"`
	Rights           *UserRightsRef `json:"rights,omitempty"`
	Roles            []*NodeRef     `json:"roles,omitempty"`
	BackedRoles      []*NodeRef     `json:"backed_roles,omitempty"`
	TensionsCreated  []*TensionRef  `json:"tensions_created,omitempty"`
	TensionsAssigned []*TensionRef  `json:"tensions_assigned,omitempty"`
	Contracts        []*ContractRef `json:"contracts,omitempty"`
	Bio              *string        `json:"bio,omitempty"`
	Utc              *string        `json:"utc,omitempty"`
}

type UserRef struct {
	ID               *string        `json:"id,omitempty"`
	CreatedAt        *string        `json:"createdAt,omitempty"`
	LastAck          *string        `json:"lastAck,omitempty"`
	Username         *string        `json:"username,omitempty"`
	Name             *string        `json:"name,omitempty"`
	Password         *string        `json:"password,omitempty"`
	Email            *string        `json:"email,omitempty"`
	EmailHash        *string        `json:"emailHash,omitempty"`
	EmailValidated   *bool          `json:"emailValidated"`
	Rights           *UserRightsRef `json:"rights,omitempty"`
	Roles            []*NodeRef     `json:"roles,omitempty"`
	BackedRoles      []*NodeRef     `json:"backed_roles,omitempty"`
	TensionsCreated  []*TensionRef  `json:"tensions_created,omitempty"`
	TensionsAssigned []*TensionRef  `json:"tensions_assigned,omitempty"`
	Contracts        []*ContractRef `json:"contracts,omitempty"`
	Bio              *string        `json:"bio,omitempty"`
	Utc              *string        `json:"utc,omitempty"`
}

type UserRights struct {
	CanLogin      bool     `json:"canLogin"`
	CanCreateRoot bool     `json:"canCreateRoot"`
	MaxPublicOrga int      `json:"maxPublicOrga,omitempty"`
	Type          UserType `json:"type_,omitempty"`
}

type UserRightsAggregateResult struct {
	Count            *int     `json:"count,omitempty"`
	MaxPublicOrgaMin *int     `json:"maxPublicOrgaMin,omitempty"`
	MaxPublicOrgaMax *int     `json:"maxPublicOrgaMax,omitempty"`
	MaxPublicOrgaSum *int     `json:"maxPublicOrgaSum,omitempty"`
	MaxPublicOrgaAvg *float64 `json:"maxPublicOrgaAvg,omitempty"`
}

type UserRightsFilter struct {
	Has []*UserRightsHasFilter `json:"has,omitempty"`
	And []*UserRightsFilter    `json:"and,omitempty"`
	Or  []*UserRightsFilter    `json:"or,omitempty"`
	Not *UserRightsFilter      `json:"not,omitempty"`
}

type UserRightsOrder struct {
	Asc  *UserRightsOrderable `json:"asc,omitempty"`
	Desc *UserRightsOrderable `json:"desc,omitempty"`
	Then *UserRightsOrder     `json:"then,omitempty"`
}

type UserRightsPatch struct {
	CanLogin      *bool     `json:"canLogin"`
	CanCreateRoot *bool     `json:"canCreateRoot"`
	MaxPublicOrga *int      `json:"maxPublicOrga,omitempty"`
	Type          *UserType `json:"type_,omitempty"`
}

type UserRightsRef struct {
	CanLogin      *bool     `json:"canLogin"`
	CanCreateRoot *bool     `json:"canCreateRoot"`
	MaxPublicOrga *int      `json:"maxPublicOrga,omitempty"`
	Type          *UserType `json:"type_,omitempty"`
}

type Vote struct {
	ID       string    `json:"id,omitempty"`
	Contract *Contract `json:"contract,omitempty"`
	Node     *Node     `json:"node,omitempty"`
	Data     []int     `json:"data,omitempty"`
}

type VoteAggregateResult struct {
	Count *int `json:"count,omitempty"`
}

type VoteFilter struct {
	ID  []string         `json:"id,omitempty"`
	Has []*VoteHasFilter `json:"has,omitempty"`
	And []*VoteFilter    `json:"and,omitempty"`
	Or  []*VoteFilter    `json:"or,omitempty"`
	Not *VoteFilter      `json:"not,omitempty"`
}

type VotePatch struct {
	Contract *ContractRef `json:"contract,omitempty"`
	Node     *NodeRef     `json:"node,omitempty"`
	Data     []int        `json:"data,omitempty"`
}

type VoteRef struct {
	ID       *string      `json:"id,omitempty"`
	Contract *ContractRef `json:"contract,omitempty"`
	Node     *NodeRef     `json:"node,omitempty"`
	Data     []int        `json:"data,omitempty"`
}

type WithinFilter struct {
	Polygon *PolygonRef `json:"polygon,omitempty"`
}

type BlobHasFilter string

const (
	BlobHasFilterCreatedBy    BlobHasFilter = "createdBy"
	BlobHasFilterCreatedAt    BlobHasFilter = "createdAt"
	BlobHasFilterUpdatedAt    BlobHasFilter = "updatedAt"
	BlobHasFilterMessage      BlobHasFilter = "message"
	BlobHasFilterTension      BlobHasFilter = "tension"
	BlobHasFilterBlobType     BlobHasFilter = "blob_type"
	BlobHasFilterPushedFlag   BlobHasFilter = "pushedFlag"
	BlobHasFilterArchivedFlag BlobHasFilter = "archivedFlag"
	BlobHasFilterNode         BlobHasFilter = "node"
	BlobHasFilterMd           BlobHasFilter = "md"
)

var AllBlobHasFilter = []BlobHasFilter{
	BlobHasFilterCreatedBy,
	BlobHasFilterCreatedAt,
	BlobHasFilterUpdatedAt,
	BlobHasFilterMessage,
	BlobHasFilterTension,
	BlobHasFilterBlobType,
	BlobHasFilterPushedFlag,
	BlobHasFilterArchivedFlag,
	BlobHasFilterNode,
	BlobHasFilterMd,
}

func (e BlobHasFilter) IsValid() bool {
	switch e {
	case BlobHasFilterCreatedBy, BlobHasFilterCreatedAt, BlobHasFilterUpdatedAt, BlobHasFilterMessage, BlobHasFilterTension, BlobHasFilterBlobType, BlobHasFilterPushedFlag, BlobHasFilterArchivedFlag, BlobHasFilterNode, BlobHasFilterMd:
		return true
	}
	return false
}

func (e BlobHasFilter) String() string {
	return string(e)
}

func (e *BlobHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BlobHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BlobHasFilter", str)
	}
	return nil
}

func (e BlobHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type BlobOrderable string

const (
	BlobOrderableCreatedAt    BlobOrderable = "createdAt"
	BlobOrderableUpdatedAt    BlobOrderable = "updatedAt"
	BlobOrderableMessage      BlobOrderable = "message"
	BlobOrderablePushedFlag   BlobOrderable = "pushedFlag"
	BlobOrderableArchivedFlag BlobOrderable = "archivedFlag"
	BlobOrderableMd           BlobOrderable = "md"
)

var AllBlobOrderable = []BlobOrderable{
	BlobOrderableCreatedAt,
	BlobOrderableUpdatedAt,
	BlobOrderableMessage,
	BlobOrderablePushedFlag,
	BlobOrderableArchivedFlag,
	BlobOrderableMd,
}

func (e BlobOrderable) IsValid() bool {
	switch e {
	case BlobOrderableCreatedAt, BlobOrderableUpdatedAt, BlobOrderableMessage, BlobOrderablePushedFlag, BlobOrderableArchivedFlag, BlobOrderableMd:
		return true
	}
	return false
}

func (e BlobOrderable) String() string {
	return string(e)
}

func (e *BlobOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BlobOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BlobOrderable", str)
	}
	return nil
}

func (e BlobOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type BlobType string

const (
	BlobTypeOnNode      BlobType = "OnNode"
	BlobTypeOnAbout     BlobType = "OnAbout"
	BlobTypeOnMandate   BlobType = "OnMandate"
	BlobTypeOnFirstLink BlobType = "OnFirstLink"
	BlobTypeOnDoc       BlobType = "OnDoc"
)

var AllBlobType = []BlobType{
	BlobTypeOnNode,
	BlobTypeOnAbout,
	BlobTypeOnMandate,
	BlobTypeOnFirstLink,
	BlobTypeOnDoc,
}

func (e BlobType) IsValid() bool {
	switch e {
	case BlobTypeOnNode, BlobTypeOnAbout, BlobTypeOnMandate, BlobTypeOnFirstLink, BlobTypeOnDoc:
		return true
	}
	return false
}

func (e BlobType) String() string {
	return string(e)
}

func (e *BlobType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BlobType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BlobType", str)
	}
	return nil
}

func (e BlobType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CommentHasFilter string

const (
	CommentHasFilterCreatedBy CommentHasFilter = "createdBy"
	CommentHasFilterCreatedAt CommentHasFilter = "createdAt"
	CommentHasFilterUpdatedAt CommentHasFilter = "updatedAt"
	CommentHasFilterMessage   CommentHasFilter = "message"
	CommentHasFilterVoid      CommentHasFilter = "_VOID"
)

var AllCommentHasFilter = []CommentHasFilter{
	CommentHasFilterCreatedBy,
	CommentHasFilterCreatedAt,
	CommentHasFilterUpdatedAt,
	CommentHasFilterMessage,
	CommentHasFilterVoid,
}

func (e CommentHasFilter) IsValid() bool {
	switch e {
	case CommentHasFilterCreatedBy, CommentHasFilterCreatedAt, CommentHasFilterUpdatedAt, CommentHasFilterMessage, CommentHasFilterVoid:
		return true
	}
	return false
}

func (e CommentHasFilter) String() string {
	return string(e)
}

func (e *CommentHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CommentHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CommentHasFilter", str)
	}
	return nil
}

func (e CommentHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CommentOrderable string

const (
	CommentOrderableCreatedAt CommentOrderable = "createdAt"
	CommentOrderableUpdatedAt CommentOrderable = "updatedAt"
	CommentOrderableMessage   CommentOrderable = "message"
	CommentOrderableVoid      CommentOrderable = "_VOID"
)

var AllCommentOrderable = []CommentOrderable{
	CommentOrderableCreatedAt,
	CommentOrderableUpdatedAt,
	CommentOrderableMessage,
	CommentOrderableVoid,
}

func (e CommentOrderable) IsValid() bool {
	switch e {
	case CommentOrderableCreatedAt, CommentOrderableUpdatedAt, CommentOrderableMessage, CommentOrderableVoid:
		return true
	}
	return false
}

func (e CommentOrderable) String() string {
	return string(e)
}

func (e *CommentOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CommentOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CommentOrderable", str)
	}
	return nil
}

func (e CommentOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ContractHasFilter string

const (
	ContractHasFilterCreatedBy    ContractHasFilter = "createdBy"
	ContractHasFilterCreatedAt    ContractHasFilter = "createdAt"
	ContractHasFilterUpdatedAt    ContractHasFilter = "updatedAt"
	ContractHasFilterMessage      ContractHasFilter = "message"
	ContractHasFilterTension      ContractHasFilter = "tension"
	ContractHasFilterStatus       ContractHasFilter = "status"
	ContractHasFilterContractType ContractHasFilter = "contract_type"
	ContractHasFilterClosedAt     ContractHasFilter = "closedAt"
	ContractHasFilterEvent        ContractHasFilter = "event"
	ContractHasFilterCandidates   ContractHasFilter = "candidates"
	ContractHasFilterParticipants ContractHasFilter = "participants"
	ContractHasFilterComments     ContractHasFilter = "comments"
)

var AllContractHasFilter = []ContractHasFilter{
	ContractHasFilterCreatedBy,
	ContractHasFilterCreatedAt,
	ContractHasFilterUpdatedAt,
	ContractHasFilterMessage,
	ContractHasFilterTension,
	ContractHasFilterStatus,
	ContractHasFilterContractType,
	ContractHasFilterClosedAt,
	ContractHasFilterEvent,
	ContractHasFilterCandidates,
	ContractHasFilterParticipants,
	ContractHasFilterComments,
}

func (e ContractHasFilter) IsValid() bool {
	switch e {
	case ContractHasFilterCreatedBy, ContractHasFilterCreatedAt, ContractHasFilterUpdatedAt, ContractHasFilterMessage, ContractHasFilterTension, ContractHasFilterStatus, ContractHasFilterContractType, ContractHasFilterClosedAt, ContractHasFilterEvent, ContractHasFilterCandidates, ContractHasFilterParticipants, ContractHasFilterComments:
		return true
	}
	return false
}

func (e ContractHasFilter) String() string {
	return string(e)
}

func (e *ContractHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ContractHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ContractHasFilter", str)
	}
	return nil
}

func (e ContractHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ContractOrderable string

const (
	ContractOrderableCreatedAt ContractOrderable = "createdAt"
	ContractOrderableUpdatedAt ContractOrderable = "updatedAt"
	ContractOrderableMessage   ContractOrderable = "message"
	ContractOrderableClosedAt  ContractOrderable = "closedAt"
)

var AllContractOrderable = []ContractOrderable{
	ContractOrderableCreatedAt,
	ContractOrderableUpdatedAt,
	ContractOrderableMessage,
	ContractOrderableClosedAt,
}

func (e ContractOrderable) IsValid() bool {
	switch e {
	case ContractOrderableCreatedAt, ContractOrderableUpdatedAt, ContractOrderableMessage, ContractOrderableClosedAt:
		return true
	}
	return false
}

func (e ContractOrderable) String() string {
	return string(e)
}

func (e *ContractOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ContractOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ContractOrderable", str)
	}
	return nil
}

func (e ContractOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ContractStatus string

const (
	ContractStatusOpen     ContractStatus = "Open"
	ContractStatusClosed   ContractStatus = "Closed"
	ContractStatusCanceled ContractStatus = "Canceled"
)

var AllContractStatus = []ContractStatus{
	ContractStatusOpen,
	ContractStatusClosed,
	ContractStatusCanceled,
}

func (e ContractStatus) IsValid() bool {
	switch e {
	case ContractStatusOpen, ContractStatusClosed, ContractStatusCanceled:
		return true
	}
	return false
}

func (e ContractStatus) String() string {
	return string(e)
}

func (e *ContractStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ContractStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ContractStatus", str)
	}
	return nil
}

func (e ContractStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ContractType string

const (
	ContractTypeAnyCoordoDual   ContractType = "AnyCoordoDual"
	ContractTypeAnyParticipants ContractType = "AnyParticipants"
	ContractTypeAnyCoordoSource ContractType = "AnyCoordoSource"
	ContractTypeAnyCoordoTarget ContractType = "AnyCoordoTarget"
)

var AllContractType = []ContractType{
	ContractTypeAnyCoordoDual,
	ContractTypeAnyParticipants,
	ContractTypeAnyCoordoSource,
	ContractTypeAnyCoordoTarget,
}

func (e ContractType) IsValid() bool {
	switch e {
	case ContractTypeAnyCoordoDual, ContractTypeAnyParticipants, ContractTypeAnyCoordoSource, ContractTypeAnyCoordoTarget:
		return true
	}
	return false
}

func (e ContractType) String() string {
	return string(e)
}

func (e *ContractType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ContractType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ContractType", str)
	}
	return nil
}

func (e ContractType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DgraphIndex string

const (
	DgraphIndexInt      DgraphIndex = "int"
	DgraphIndexInt64    DgraphIndex = "int64"
	DgraphIndexFloat    DgraphIndex = "float"
	DgraphIndexBool     DgraphIndex = "bool"
	DgraphIndexHash     DgraphIndex = "hash"
	DgraphIndexExact    DgraphIndex = "exact"
	DgraphIndexTerm     DgraphIndex = "term"
	DgraphIndexFulltext DgraphIndex = "fulltext"
	DgraphIndexTrigram  DgraphIndex = "trigram"
	DgraphIndexRegexp   DgraphIndex = "regexp"
	DgraphIndexYear     DgraphIndex = "year"
	DgraphIndexMonth    DgraphIndex = "month"
	DgraphIndexDay      DgraphIndex = "day"
	DgraphIndexHour     DgraphIndex = "hour"
	DgraphIndexGeo      DgraphIndex = "geo"
)

var AllDgraphIndex = []DgraphIndex{
	DgraphIndexInt,
	DgraphIndexInt64,
	DgraphIndexFloat,
	DgraphIndexBool,
	DgraphIndexHash,
	DgraphIndexExact,
	DgraphIndexTerm,
	DgraphIndexFulltext,
	DgraphIndexTrigram,
	DgraphIndexRegexp,
	DgraphIndexYear,
	DgraphIndexMonth,
	DgraphIndexDay,
	DgraphIndexHour,
	DgraphIndexGeo,
}

func (e DgraphIndex) IsValid() bool {
	switch e {
	case DgraphIndexInt, DgraphIndexInt64, DgraphIndexFloat, DgraphIndexBool, DgraphIndexHash, DgraphIndexExact, DgraphIndexTerm, DgraphIndexFulltext, DgraphIndexTrigram, DgraphIndexRegexp, DgraphIndexYear, DgraphIndexMonth, DgraphIndexDay, DgraphIndexHour, DgraphIndexGeo:
		return true
	}
	return false
}

func (e DgraphIndex) String() string {
	return string(e)
}

func (e *DgraphIndex) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DgraphIndex(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DgraphIndex", str)
	}
	return nil
}

func (e DgraphIndex) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EventFragmentHasFilter string

const (
	EventFragmentHasFilterEventType EventFragmentHasFilter = "event_type"
	EventFragmentHasFilterOld       EventFragmentHasFilter = "old"
	EventFragmentHasFilterNew       EventFragmentHasFilter = "new"
)

var AllEventFragmentHasFilter = []EventFragmentHasFilter{
	EventFragmentHasFilterEventType,
	EventFragmentHasFilterOld,
	EventFragmentHasFilterNew,
}

func (e EventFragmentHasFilter) IsValid() bool {
	switch e {
	case EventFragmentHasFilterEventType, EventFragmentHasFilterOld, EventFragmentHasFilterNew:
		return true
	}
	return false
}

func (e EventFragmentHasFilter) String() string {
	return string(e)
}

func (e *EventFragmentHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EventFragmentHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EventFragmentHasFilter", str)
	}
	return nil
}

func (e EventFragmentHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EventFragmentOrderable string

const (
	EventFragmentOrderableOld EventFragmentOrderable = "old"
	EventFragmentOrderableNew EventFragmentOrderable = "new"
)

var AllEventFragmentOrderable = []EventFragmentOrderable{
	EventFragmentOrderableOld,
	EventFragmentOrderableNew,
}

func (e EventFragmentOrderable) IsValid() bool {
	switch e {
	case EventFragmentOrderableOld, EventFragmentOrderableNew:
		return true
	}
	return false
}

func (e EventFragmentOrderable) String() string {
	return string(e)
}

func (e *EventFragmentOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EventFragmentOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EventFragmentOrderable", str)
	}
	return nil
}

func (e EventFragmentOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EventHasFilter string

const (
	EventHasFilterCreatedBy EventHasFilter = "createdBy"
	EventHasFilterCreatedAt EventHasFilter = "createdAt"
	EventHasFilterUpdatedAt EventHasFilter = "updatedAt"
	EventHasFilterMessage   EventHasFilter = "message"
	EventHasFilterTension   EventHasFilter = "tension"
	EventHasFilterEventType EventHasFilter = "event_type"
	EventHasFilterOld       EventHasFilter = "old"
	EventHasFilterNew       EventHasFilter = "new"
)

var AllEventHasFilter = []EventHasFilter{
	EventHasFilterCreatedBy,
	EventHasFilterCreatedAt,
	EventHasFilterUpdatedAt,
	EventHasFilterMessage,
	EventHasFilterTension,
	EventHasFilterEventType,
	EventHasFilterOld,
	EventHasFilterNew,
}

func (e EventHasFilter) IsValid() bool {
	switch e {
	case EventHasFilterCreatedBy, EventHasFilterCreatedAt, EventHasFilterUpdatedAt, EventHasFilterMessage, EventHasFilterTension, EventHasFilterEventType, EventHasFilterOld, EventHasFilterNew:
		return true
	}
	return false
}

func (e EventHasFilter) String() string {
	return string(e)
}

func (e *EventHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EventHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EventHasFilter", str)
	}
	return nil
}

func (e EventHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EventOrderable string

const (
	EventOrderableCreatedAt EventOrderable = "createdAt"
	EventOrderableUpdatedAt EventOrderable = "updatedAt"
	EventOrderableMessage   EventOrderable = "message"
	EventOrderableOld       EventOrderable = "old"
	EventOrderableNew       EventOrderable = "new"
)

var AllEventOrderable = []EventOrderable{
	EventOrderableCreatedAt,
	EventOrderableUpdatedAt,
	EventOrderableMessage,
	EventOrderableOld,
	EventOrderableNew,
}

func (e EventOrderable) IsValid() bool {
	switch e {
	case EventOrderableCreatedAt, EventOrderableUpdatedAt, EventOrderableMessage, EventOrderableOld, EventOrderableNew:
		return true
	}
	return false
}

func (e EventOrderable) String() string {
	return string(e)
}

func (e *EventOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EventOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EventOrderable", str)
	}
	return nil
}

func (e EventOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type HTTPMethod string

const (
	HTTPMethodGet    HTTPMethod = "GET"
	HTTPMethodPost   HTTPMethod = "POST"
	HTTPMethodPut    HTTPMethod = "PUT"
	HTTPMethodPatch  HTTPMethod = "PATCH"
	HTTPMethodDelete HTTPMethod = "DELETE"
)

var AllHTTPMethod = []HTTPMethod{
	HTTPMethodGet,
	HTTPMethodPost,
	HTTPMethodPut,
	HTTPMethodPatch,
	HTTPMethodDelete,
}

func (e HTTPMethod) IsValid() bool {
	switch e {
	case HTTPMethodGet, HTTPMethodPost, HTTPMethodPut, HTTPMethodPatch, HTTPMethodDelete:
		return true
	}
	return false
}

func (e HTTPMethod) String() string {
	return string(e)
}

func (e *HTTPMethod) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HTTPMethod(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HTTPMethod", str)
	}
	return nil
}

func (e HTTPMethod) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type LabelHasFilter string

const (
	LabelHasFilterRootnameid  LabelHasFilter = "rootnameid"
	LabelHasFilterName        LabelHasFilter = "name"
	LabelHasFilterDescription LabelHasFilter = "description"
	LabelHasFilterColor       LabelHasFilter = "color"
	LabelHasFilterTensions    LabelHasFilter = "tensions"
	LabelHasFilterNodes       LabelHasFilter = "nodes"
	LabelHasFilterNNodes      LabelHasFilter = "n_nodes"
	LabelHasFilterNTensions   LabelHasFilter = "n_tensions"
)

var AllLabelHasFilter = []LabelHasFilter{
	LabelHasFilterRootnameid,
	LabelHasFilterName,
	LabelHasFilterDescription,
	LabelHasFilterColor,
	LabelHasFilterTensions,
	LabelHasFilterNodes,
	LabelHasFilterNNodes,
	LabelHasFilterNTensions,
}

func (e LabelHasFilter) IsValid() bool {
	switch e {
	case LabelHasFilterRootnameid, LabelHasFilterName, LabelHasFilterDescription, LabelHasFilterColor, LabelHasFilterTensions, LabelHasFilterNodes, LabelHasFilterNNodes, LabelHasFilterNTensions:
		return true
	}
	return false
}

func (e LabelHasFilter) String() string {
	return string(e)
}

func (e *LabelHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LabelHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LabelHasFilter", str)
	}
	return nil
}

func (e LabelHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type LabelOrderable string

const (
	LabelOrderableRootnameid  LabelOrderable = "rootnameid"
	LabelOrderableName        LabelOrderable = "name"
	LabelOrderableDescription LabelOrderable = "description"
	LabelOrderableColor       LabelOrderable = "color"
	LabelOrderableNNodes      LabelOrderable = "n_nodes"
	LabelOrderableNTensions   LabelOrderable = "n_tensions"
)

var AllLabelOrderable = []LabelOrderable{
	LabelOrderableRootnameid,
	LabelOrderableName,
	LabelOrderableDescription,
	LabelOrderableColor,
	LabelOrderableNNodes,
	LabelOrderableNTensions,
}

func (e LabelOrderable) IsValid() bool {
	switch e {
	case LabelOrderableRootnameid, LabelOrderableName, LabelOrderableDescription, LabelOrderableColor, LabelOrderableNNodes, LabelOrderableNTensions:
		return true
	}
	return false
}

func (e LabelOrderable) String() string {
	return string(e)
}

func (e *LabelOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LabelOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LabelOrderable", str)
	}
	return nil
}

func (e LabelOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type MandateHasFilter string

const (
	MandateHasFilterPurpose          MandateHasFilter = "purpose"
	MandateHasFilterResponsabilities MandateHasFilter = "responsabilities"
	MandateHasFilterDomains          MandateHasFilter = "domains"
	MandateHasFilterPolicies         MandateHasFilter = "policies"
)

var AllMandateHasFilter = []MandateHasFilter{
	MandateHasFilterPurpose,
	MandateHasFilterResponsabilities,
	MandateHasFilterDomains,
	MandateHasFilterPolicies,
}

func (e MandateHasFilter) IsValid() bool {
	switch e {
	case MandateHasFilterPurpose, MandateHasFilterResponsabilities, MandateHasFilterDomains, MandateHasFilterPolicies:
		return true
	}
	return false
}

func (e MandateHasFilter) String() string {
	return string(e)
}

func (e *MandateHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MandateHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MandateHasFilter", str)
	}
	return nil
}

func (e MandateHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type MandateOrderable string

const (
	MandateOrderablePurpose          MandateOrderable = "purpose"
	MandateOrderableResponsabilities MandateOrderable = "responsabilities"
	MandateOrderableDomains          MandateOrderable = "domains"
	MandateOrderablePolicies         MandateOrderable = "policies"
)

var AllMandateOrderable = []MandateOrderable{
	MandateOrderablePurpose,
	MandateOrderableResponsabilities,
	MandateOrderableDomains,
	MandateOrderablePolicies,
}

func (e MandateOrderable) IsValid() bool {
	switch e {
	case MandateOrderablePurpose, MandateOrderableResponsabilities, MandateOrderableDomains, MandateOrderablePolicies:
		return true
	}
	return false
}

func (e MandateOrderable) String() string {
	return string(e)
}

func (e *MandateOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MandateOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MandateOrderable", str)
	}
	return nil
}

func (e MandateOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Mode string

const (
	ModeBatch  Mode = "BATCH"
	ModeSingle Mode = "SINGLE"
)

var AllMode = []Mode{
	ModeBatch,
	ModeSingle,
}

func (e Mode) IsValid() bool {
	switch e {
	case ModeBatch, ModeSingle:
		return true
	}
	return false
}

func (e Mode) String() string {
	return string(e)
}

func (e *Mode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Mode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Mode", str)
	}
	return nil
}

func (e Mode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type NodeCharacHasFilter string

const (
	NodeCharacHasFilterUserCanJoin NodeCharacHasFilter = "userCanJoin"
	NodeCharacHasFilterMode        NodeCharacHasFilter = "mode"
)

var AllNodeCharacHasFilter = []NodeCharacHasFilter{
	NodeCharacHasFilterUserCanJoin,
	NodeCharacHasFilterMode,
}

func (e NodeCharacHasFilter) IsValid() bool {
	switch e {
	case NodeCharacHasFilterUserCanJoin, NodeCharacHasFilterMode:
		return true
	}
	return false
}

func (e NodeCharacHasFilter) String() string {
	return string(e)
}

func (e *NodeCharacHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NodeCharacHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NodeCharacHasFilter", str)
	}
	return nil
}

func (e NodeCharacHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type NodeFragmentHasFilter string

const (
	NodeFragmentHasFilterName       NodeFragmentHasFilter = "name"
	NodeFragmentHasFilterNameid     NodeFragmentHasFilter = "nameid"
	NodeFragmentHasFilterType       NodeFragmentHasFilter = "type_"
	NodeFragmentHasFilterIsPrivate  NodeFragmentHasFilter = "isPrivate"
	NodeFragmentHasFilterCharac     NodeFragmentHasFilter = "charac"
	NodeFragmentHasFilterAbout      NodeFragmentHasFilter = "about"
	NodeFragmentHasFilterMandate    NodeFragmentHasFilter = "mandate"
	NodeFragmentHasFilterChildren   NodeFragmentHasFilter = "children"
	NodeFragmentHasFilterFirstLink  NodeFragmentHasFilter = "first_link"
	NodeFragmentHasFilterSecondLink NodeFragmentHasFilter = "second_link"
	NodeFragmentHasFilterSkills     NodeFragmentHasFilter = "skills"
	NodeFragmentHasFilterRoleType   NodeFragmentHasFilter = "role_type"
)

var AllNodeFragmentHasFilter = []NodeFragmentHasFilter{
	NodeFragmentHasFilterName,
	NodeFragmentHasFilterNameid,
	NodeFragmentHasFilterType,
	NodeFragmentHasFilterIsPrivate,
	NodeFragmentHasFilterCharac,
	NodeFragmentHasFilterAbout,
	NodeFragmentHasFilterMandate,
	NodeFragmentHasFilterChildren,
	NodeFragmentHasFilterFirstLink,
	NodeFragmentHasFilterSecondLink,
	NodeFragmentHasFilterSkills,
	NodeFragmentHasFilterRoleType,
}

func (e NodeFragmentHasFilter) IsValid() bool {
	switch e {
	case NodeFragmentHasFilterName, NodeFragmentHasFilterNameid, NodeFragmentHasFilterType, NodeFragmentHasFilterIsPrivate, NodeFragmentHasFilterCharac, NodeFragmentHasFilterAbout, NodeFragmentHasFilterMandate, NodeFragmentHasFilterChildren, NodeFragmentHasFilterFirstLink, NodeFragmentHasFilterSecondLink, NodeFragmentHasFilterSkills, NodeFragmentHasFilterRoleType:
		return true
	}
	return false
}

func (e NodeFragmentHasFilter) String() string {
	return string(e)
}

func (e *NodeFragmentHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NodeFragmentHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NodeFragmentHasFilter", str)
	}
	return nil
}

func (e NodeFragmentHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type NodeFragmentOrderable string

const (
	NodeFragmentOrderableName       NodeFragmentOrderable = "name"
	NodeFragmentOrderableNameid     NodeFragmentOrderable = "nameid"
	NodeFragmentOrderableAbout      NodeFragmentOrderable = "about"
	NodeFragmentOrderableFirstLink  NodeFragmentOrderable = "first_link"
	NodeFragmentOrderableSecondLink NodeFragmentOrderable = "second_link"
)

var AllNodeFragmentOrderable = []NodeFragmentOrderable{
	NodeFragmentOrderableName,
	NodeFragmentOrderableNameid,
	NodeFragmentOrderableAbout,
	NodeFragmentOrderableFirstLink,
	NodeFragmentOrderableSecondLink,
}

func (e NodeFragmentOrderable) IsValid() bool {
	switch e {
	case NodeFragmentOrderableName, NodeFragmentOrderableNameid, NodeFragmentOrderableAbout, NodeFragmentOrderableFirstLink, NodeFragmentOrderableSecondLink:
		return true
	}
	return false
}

func (e NodeFragmentOrderable) String() string {
	return string(e)
}

func (e *NodeFragmentOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NodeFragmentOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NodeFragmentOrderable", str)
	}
	return nil
}

func (e NodeFragmentOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type NodeHasFilter string

const (
	NodeHasFilterCreatedBy    NodeHasFilter = "createdBy"
	NodeHasFilterCreatedAt    NodeHasFilter = "createdAt"
	NodeHasFilterUpdatedAt    NodeHasFilter = "updatedAt"
	NodeHasFilterName         NodeHasFilter = "name"
	NodeHasFilterNameid       NodeHasFilter = "nameid"
	NodeHasFilterRootnameid   NodeHasFilter = "rootnameid"
	NodeHasFilterParent       NodeHasFilter = "parent"
	NodeHasFilterChildren     NodeHasFilter = "children"
	NodeHasFilterType         NodeHasFilter = "type_"
	NodeHasFilterTensionsOut  NodeHasFilter = "tensions_out"
	NodeHasFilterTensionsIn   NodeHasFilter = "tensions_in"
	NodeHasFilterAbout        NodeHasFilter = "about"
	NodeHasFilterMandate      NodeHasFilter = "mandate"
	NodeHasFilterDocs         NodeHasFilter = "docs"
	NodeHasFilterSource       NodeHasFilter = "source"
	NodeHasFilterNTensionsOut NodeHasFilter = "n_tensions_out"
	NodeHasFilterNTensionsIn  NodeHasFilter = "n_tensions_in"
	NodeHasFilterNChildren    NodeHasFilter = "n_children"
	NodeHasFilterStats        NodeHasFilter = "stats"
	NodeHasFilterIsRoot       NodeHasFilter = "isRoot"
	NodeHasFilterIsPersonal   NodeHasFilter = "isPersonal"
	NodeHasFilterIsPrivate    NodeHasFilter = "isPrivate"
	NodeHasFilterIsArchived   NodeHasFilter = "isArchived"
	NodeHasFilterCharac       NodeHasFilter = "charac"
	NodeHasFilterRights       NodeHasFilter = "rights"
	NodeHasFilterLabels       NodeHasFilter = "labels"
	NodeHasFilterFirstLink    NodeHasFilter = "first_link"
	NodeHasFilterSecondLink   NodeHasFilter = "second_link"
	NodeHasFilterSkills       NodeHasFilter = "skills"
	NodeHasFilterRoleType     NodeHasFilter = "role_type"
	NodeHasFilterContracts    NodeHasFilter = "contracts"
	NodeHasFilterShared       NodeHasFilter = "shared"
)

var AllNodeHasFilter = []NodeHasFilter{
	NodeHasFilterCreatedBy,
	NodeHasFilterCreatedAt,
	NodeHasFilterUpdatedAt,
	NodeHasFilterName,
	NodeHasFilterNameid,
	NodeHasFilterRootnameid,
	NodeHasFilterParent,
	NodeHasFilterChildren,
	NodeHasFilterType,
	NodeHasFilterTensionsOut,
	NodeHasFilterTensionsIn,
	NodeHasFilterAbout,
	NodeHasFilterMandate,
	NodeHasFilterDocs,
	NodeHasFilterSource,
	NodeHasFilterNTensionsOut,
	NodeHasFilterNTensionsIn,
	NodeHasFilterNChildren,
	NodeHasFilterStats,
	NodeHasFilterIsRoot,
	NodeHasFilterIsPersonal,
	NodeHasFilterIsPrivate,
	NodeHasFilterIsArchived,
	NodeHasFilterCharac,
	NodeHasFilterRights,
	NodeHasFilterLabels,
	NodeHasFilterFirstLink,
	NodeHasFilterSecondLink,
	NodeHasFilterSkills,
	NodeHasFilterRoleType,
	NodeHasFilterContracts,
	NodeHasFilterShared,
}

func (e NodeHasFilter) IsValid() bool {
	switch e {
	case NodeHasFilterCreatedBy, NodeHasFilterCreatedAt, NodeHasFilterUpdatedAt, NodeHasFilterName, NodeHasFilterNameid, NodeHasFilterRootnameid, NodeHasFilterParent, NodeHasFilterChildren, NodeHasFilterType, NodeHasFilterTensionsOut, NodeHasFilterTensionsIn, NodeHasFilterAbout, NodeHasFilterMandate, NodeHasFilterDocs, NodeHasFilterSource, NodeHasFilterNTensionsOut, NodeHasFilterNTensionsIn, NodeHasFilterNChildren, NodeHasFilterStats, NodeHasFilterIsRoot, NodeHasFilterIsPersonal, NodeHasFilterIsPrivate, NodeHasFilterIsArchived, NodeHasFilterCharac, NodeHasFilterRights, NodeHasFilterLabels, NodeHasFilterFirstLink, NodeHasFilterSecondLink, NodeHasFilterSkills, NodeHasFilterRoleType, NodeHasFilterContracts, NodeHasFilterShared:
		return true
	}
	return false
}

func (e NodeHasFilter) String() string {
	return string(e)
}

func (e *NodeHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NodeHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NodeHasFilter", str)
	}
	return nil
}

func (e NodeHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type NodeMode string

const (
	NodeModeCoordinated NodeMode = "Coordinated"
	NodeModeAgile       NodeMode = "Agile"
)

var AllNodeMode = []NodeMode{
	NodeModeCoordinated,
	NodeModeAgile,
}

func (e NodeMode) IsValid() bool {
	switch e {
	case NodeModeCoordinated, NodeModeAgile:
		return true
	}
	return false
}

func (e NodeMode) String() string {
	return string(e)
}

func (e *NodeMode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NodeMode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NodeMode", str)
	}
	return nil
}

func (e NodeMode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type NodeOrderable string

const (
	NodeOrderableCreatedAt    NodeOrderable = "createdAt"
	NodeOrderableUpdatedAt    NodeOrderable = "updatedAt"
	NodeOrderableName         NodeOrderable = "name"
	NodeOrderableNameid       NodeOrderable = "nameid"
	NodeOrderableRootnameid   NodeOrderable = "rootnameid"
	NodeOrderableAbout        NodeOrderable = "about"
	NodeOrderableNTensionsOut NodeOrderable = "n_tensions_out"
	NodeOrderableNTensionsIn  NodeOrderable = "n_tensions_in"
	NodeOrderableNChildren    NodeOrderable = "n_children"
	NodeOrderableRights       NodeOrderable = "rights"
)

var AllNodeOrderable = []NodeOrderable{
	NodeOrderableCreatedAt,
	NodeOrderableUpdatedAt,
	NodeOrderableName,
	NodeOrderableNameid,
	NodeOrderableRootnameid,
	NodeOrderableAbout,
	NodeOrderableNTensionsOut,
	NodeOrderableNTensionsIn,
	NodeOrderableNChildren,
	NodeOrderableRights,
}

func (e NodeOrderable) IsValid() bool {
	switch e {
	case NodeOrderableCreatedAt, NodeOrderableUpdatedAt, NodeOrderableName, NodeOrderableNameid, NodeOrderableRootnameid, NodeOrderableAbout, NodeOrderableNTensionsOut, NodeOrderableNTensionsIn, NodeOrderableNChildren, NodeOrderableRights:
		return true
	}
	return false
}

func (e NodeOrderable) String() string {
	return string(e)
}

func (e *NodeOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NodeOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NodeOrderable", str)
	}
	return nil
}

func (e NodeOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type NodeStatsHasFilter string

const (
	NodeStatsHasFilterNMember NodeStatsHasFilter = "n_member"
	NodeStatsHasFilterNGuest  NodeStatsHasFilter = "n_guest"
	NodeStatsHasFilterNCircle NodeStatsHasFilter = "n_circle"
	NodeStatsHasFilterNRole   NodeStatsHasFilter = "n_role"
)

var AllNodeStatsHasFilter = []NodeStatsHasFilter{
	NodeStatsHasFilterNMember,
	NodeStatsHasFilterNGuest,
	NodeStatsHasFilterNCircle,
	NodeStatsHasFilterNRole,
}

func (e NodeStatsHasFilter) IsValid() bool {
	switch e {
	case NodeStatsHasFilterNMember, NodeStatsHasFilterNGuest, NodeStatsHasFilterNCircle, NodeStatsHasFilterNRole:
		return true
	}
	return false
}

func (e NodeStatsHasFilter) String() string {
	return string(e)
}

func (e *NodeStatsHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NodeStatsHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NodeStatsHasFilter", str)
	}
	return nil
}

func (e NodeStatsHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type NodeStatsOrderable string

const (
	NodeStatsOrderableNMember NodeStatsOrderable = "n_member"
	NodeStatsOrderableNGuest  NodeStatsOrderable = "n_guest"
	NodeStatsOrderableNCircle NodeStatsOrderable = "n_circle"
	NodeStatsOrderableNRole   NodeStatsOrderable = "n_role"
)

var AllNodeStatsOrderable = []NodeStatsOrderable{
	NodeStatsOrderableNMember,
	NodeStatsOrderableNGuest,
	NodeStatsOrderableNCircle,
	NodeStatsOrderableNRole,
}

func (e NodeStatsOrderable) IsValid() bool {
	switch e {
	case NodeStatsOrderableNMember, NodeStatsOrderableNGuest, NodeStatsOrderableNCircle, NodeStatsOrderableNRole:
		return true
	}
	return false
}

func (e NodeStatsOrderable) String() string {
	return string(e)
}

func (e *NodeStatsOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NodeStatsOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NodeStatsOrderable", str)
	}
	return nil
}

func (e NodeStatsOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type NodeType string

const (
	NodeTypeCircle NodeType = "Circle"
	NodeTypeRole   NodeType = "Role"
)

var AllNodeType = []NodeType{
	NodeTypeCircle,
	NodeTypeRole,
}

func (e NodeType) IsValid() bool {
	switch e {
	case NodeTypeCircle, NodeTypeRole:
		return true
	}
	return false
}

func (e NodeType) String() string {
	return string(e)
}

func (e *NodeType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NodeType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NodeType", str)
	}
	return nil
}

func (e NodeType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PostHasFilter string

const (
	PostHasFilterCreatedBy PostHasFilter = "createdBy"
	PostHasFilterCreatedAt PostHasFilter = "createdAt"
	PostHasFilterUpdatedAt PostHasFilter = "updatedAt"
	PostHasFilterMessage   PostHasFilter = "message"
)

var AllPostHasFilter = []PostHasFilter{
	PostHasFilterCreatedBy,
	PostHasFilterCreatedAt,
	PostHasFilterUpdatedAt,
	PostHasFilterMessage,
}

func (e PostHasFilter) IsValid() bool {
	switch e {
	case PostHasFilterCreatedBy, PostHasFilterCreatedAt, PostHasFilterUpdatedAt, PostHasFilterMessage:
		return true
	}
	return false
}

func (e PostHasFilter) String() string {
	return string(e)
}

func (e *PostHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PostHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PostHasFilter", str)
	}
	return nil
}

func (e PostHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PostOrderable string

const (
	PostOrderableCreatedAt PostOrderable = "createdAt"
	PostOrderableUpdatedAt PostOrderable = "updatedAt"
	PostOrderableMessage   PostOrderable = "message"
)

var AllPostOrderable = []PostOrderable{
	PostOrderableCreatedAt,
	PostOrderableUpdatedAt,
	PostOrderableMessage,
}

func (e PostOrderable) IsValid() bool {
	switch e {
	case PostOrderableCreatedAt, PostOrderableUpdatedAt, PostOrderableMessage:
		return true
	}
	return false
}

func (e PostOrderable) String() string {
	return string(e)
}

func (e *PostOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PostOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PostOrderable", str)
	}
	return nil
}

func (e PostOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RoleType string

const (
	RoleTypeOwner       RoleType = "Owner"
	RoleTypeMember      RoleType = "Member"
	RoleTypeGuest       RoleType = "Guest"
	RoleTypeRetired     RoleType = "Retired"
	RoleTypePending     RoleType = "Pending"
	RoleTypeCoordinator RoleType = "Coordinator"
	RoleTypePeer        RoleType = "Peer"
	RoleTypeBot         RoleType = "Bot"
)

var AllRoleType = []RoleType{
	RoleTypeOwner,
	RoleTypeMember,
	RoleTypeGuest,
	RoleTypeRetired,
	RoleTypePending,
	RoleTypeCoordinator,
	RoleTypePeer,
	RoleTypeBot,
}

func (e RoleType) IsValid() bool {
	switch e {
	case RoleTypeOwner, RoleTypeMember, RoleTypeGuest, RoleTypeRetired, RoleTypePending, RoleTypeCoordinator, RoleTypePeer, RoleTypeBot:
		return true
	}
	return false
}

func (e RoleType) String() string {
	return string(e)
}

func (e *RoleType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RoleType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RoleType", str)
	}
	return nil
}

func (e RoleType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SharedNodeHasFilter string

const (
	SharedNodeHasFilterNLabels         SharedNodeHasFilter = "n_labels"
	SharedNodeHasFilterNTensions       SharedNodeHasFilter = "n_tensions"
	SharedNodeHasFilterNClosedTensions SharedNodeHasFilter = "n_closed_tensions"
)

var AllSharedNodeHasFilter = []SharedNodeHasFilter{
	SharedNodeHasFilterNLabels,
	SharedNodeHasFilterNTensions,
	SharedNodeHasFilterNClosedTensions,
}

func (e SharedNodeHasFilter) IsValid() bool {
	switch e {
	case SharedNodeHasFilterNLabels, SharedNodeHasFilterNTensions, SharedNodeHasFilterNClosedTensions:
		return true
	}
	return false
}

func (e SharedNodeHasFilter) String() string {
	return string(e)
}

func (e *SharedNodeHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SharedNodeHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SharedNodeHasFilter", str)
	}
	return nil
}

func (e SharedNodeHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SharedNodeOrderable string

const (
	SharedNodeOrderableNLabels         SharedNodeOrderable = "n_labels"
	SharedNodeOrderableNTensions       SharedNodeOrderable = "n_tensions"
	SharedNodeOrderableNClosedTensions SharedNodeOrderable = "n_closed_tensions"
)

var AllSharedNodeOrderable = []SharedNodeOrderable{
	SharedNodeOrderableNLabels,
	SharedNodeOrderableNTensions,
	SharedNodeOrderableNClosedTensions,
}

func (e SharedNodeOrderable) IsValid() bool {
	switch e {
	case SharedNodeOrderableNLabels, SharedNodeOrderableNTensions, SharedNodeOrderableNClosedTensions:
		return true
	}
	return false
}

func (e SharedNodeOrderable) String() string {
	return string(e)
}

func (e *SharedNodeOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SharedNodeOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SharedNodeOrderable", str)
	}
	return nil
}

func (e SharedNodeOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TensionAction string

const (
	TensionActionNewRole        TensionAction = "NewRole"
	TensionActionNewCircle      TensionAction = "NewCircle"
	TensionActionNewMd          TensionAction = "NewMd"
	TensionActionEditRole       TensionAction = "EditRole"
	TensionActionEditCircle     TensionAction = "EditCircle"
	TensionActionEditMd         TensionAction = "EditMd"
	TensionActionArchivedRole   TensionAction = "ArchivedRole"
	TensionActionArchivedCircle TensionAction = "ArchivedCircle"
	TensionActionArchivedMd     TensionAction = "ArchivedMd"
)

var AllTensionAction = []TensionAction{
	TensionActionNewRole,
	TensionActionNewCircle,
	TensionActionNewMd,
	TensionActionEditRole,
	TensionActionEditCircle,
	TensionActionEditMd,
	TensionActionArchivedRole,
	TensionActionArchivedCircle,
	TensionActionArchivedMd,
}

func (e TensionAction) IsValid() bool {
	switch e {
	case TensionActionNewRole, TensionActionNewCircle, TensionActionNewMd, TensionActionEditRole, TensionActionEditCircle, TensionActionEditMd, TensionActionArchivedRole, TensionActionArchivedCircle, TensionActionArchivedMd:
		return true
	}
	return false
}

func (e TensionAction) String() string {
	return string(e)
}

func (e *TensionAction) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TensionAction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TensionAction", str)
	}
	return nil
}

func (e TensionAction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TensionEvent string

const (
	TensionEventCreated         TensionEvent = "Created"
	TensionEventReopened        TensionEvent = "Reopened"
	TensionEventClosed          TensionEvent = "Closed"
	TensionEventTitleUpdated    TensionEvent = "TitleUpdated"
	TensionEventCommentPushed   TensionEvent = "CommentPushed"
	TensionEventAssigneeAdded   TensionEvent = "AssigneeAdded"
	TensionEventAssigneeRemoved TensionEvent = "AssigneeRemoved"
	TensionEventLabelAdded      TensionEvent = "LabelAdded"
	TensionEventLabelRemoved    TensionEvent = "LabelRemoved"
	TensionEventBlobCreated     TensionEvent = "BlobCreated"
	TensionEventBlobCommitted   TensionEvent = "BlobCommitted"
	TensionEventBlobPushed      TensionEvent = "BlobPushed"
	TensionEventBlobArchived    TensionEvent = "BlobArchived"
	TensionEventBlobUnarchived  TensionEvent = "BlobUnarchived"
	TensionEventUserJoined      TensionEvent = "UserJoined"
	TensionEventUserLeft        TensionEvent = "UserLeft"
	TensionEventMoved           TensionEvent = "Moved"
)

var AllTensionEvent = []TensionEvent{
	TensionEventCreated,
	TensionEventReopened,
	TensionEventClosed,
	TensionEventTitleUpdated,
	TensionEventCommentPushed,
	TensionEventAssigneeAdded,
	TensionEventAssigneeRemoved,
	TensionEventLabelAdded,
	TensionEventLabelRemoved,
	TensionEventBlobCreated,
	TensionEventBlobCommitted,
	TensionEventBlobPushed,
	TensionEventBlobArchived,
	TensionEventBlobUnarchived,
	TensionEventUserJoined,
	TensionEventUserLeft,
	TensionEventMoved,
}

func (e TensionEvent) IsValid() bool {
	switch e {
	case TensionEventCreated, TensionEventReopened, TensionEventClosed, TensionEventTitleUpdated, TensionEventCommentPushed, TensionEventAssigneeAdded, TensionEventAssigneeRemoved, TensionEventLabelAdded, TensionEventLabelRemoved, TensionEventBlobCreated, TensionEventBlobCommitted, TensionEventBlobPushed, TensionEventBlobArchived, TensionEventBlobUnarchived, TensionEventUserJoined, TensionEventUserLeft, TensionEventMoved:
		return true
	}
	return false
}

func (e TensionEvent) String() string {
	return string(e)
}

func (e *TensionEvent) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TensionEvent(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TensionEvent", str)
	}
	return nil
}

func (e TensionEvent) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TensionHasFilter string

const (
	TensionHasFilterCreatedBy  TensionHasFilter = "createdBy"
	TensionHasFilterCreatedAt  TensionHasFilter = "createdAt"
	TensionHasFilterUpdatedAt  TensionHasFilter = "updatedAt"
	TensionHasFilterMessage    TensionHasFilter = "message"
	TensionHasFilterEmitterid  TensionHasFilter = "emitterid"
	TensionHasFilterEmitter    TensionHasFilter = "emitter"
	TensionHasFilterReceiverid TensionHasFilter = "receiverid"
	TensionHasFilterReceiver   TensionHasFilter = "receiver"
	TensionHasFilterNth        TensionHasFilter = "nth"
	TensionHasFilterTitle      TensionHasFilter = "title"
	TensionHasFilterType       TensionHasFilter = "type_"
	TensionHasFilterStatus     TensionHasFilter = "status"
	TensionHasFilterAssignees  TensionHasFilter = "assignees"
	TensionHasFilterLabels     TensionHasFilter = "labels"
	TensionHasFilterComments   TensionHasFilter = "comments"
	TensionHasFilterAction     TensionHasFilter = "action"
	TensionHasFilterBlobs      TensionHasFilter = "blobs"
	TensionHasFilterContracts  TensionHasFilter = "contracts"
	TensionHasFilterHistory    TensionHasFilter = "history"
	TensionHasFilterNComments  TensionHasFilter = "n_comments"
	TensionHasFilterNBlobs     TensionHasFilter = "n_blobs"
)

var AllTensionHasFilter = []TensionHasFilter{
	TensionHasFilterCreatedBy,
	TensionHasFilterCreatedAt,
	TensionHasFilterUpdatedAt,
	TensionHasFilterMessage,
	TensionHasFilterEmitterid,
	TensionHasFilterEmitter,
	TensionHasFilterReceiverid,
	TensionHasFilterReceiver,
	TensionHasFilterNth,
	TensionHasFilterTitle,
	TensionHasFilterType,
	TensionHasFilterStatus,
	TensionHasFilterAssignees,
	TensionHasFilterLabels,
	TensionHasFilterComments,
	TensionHasFilterAction,
	TensionHasFilterBlobs,
	TensionHasFilterContracts,
	TensionHasFilterHistory,
	TensionHasFilterNComments,
	TensionHasFilterNBlobs,
}

func (e TensionHasFilter) IsValid() bool {
	switch e {
	case TensionHasFilterCreatedBy, TensionHasFilterCreatedAt, TensionHasFilterUpdatedAt, TensionHasFilterMessage, TensionHasFilterEmitterid, TensionHasFilterEmitter, TensionHasFilterReceiverid, TensionHasFilterReceiver, TensionHasFilterNth, TensionHasFilterTitle, TensionHasFilterType, TensionHasFilterStatus, TensionHasFilterAssignees, TensionHasFilterLabels, TensionHasFilterComments, TensionHasFilterAction, TensionHasFilterBlobs, TensionHasFilterContracts, TensionHasFilterHistory, TensionHasFilterNComments, TensionHasFilterNBlobs:
		return true
	}
	return false
}

func (e TensionHasFilter) String() string {
	return string(e)
}

func (e *TensionHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TensionHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TensionHasFilter", str)
	}
	return nil
}

func (e TensionHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TensionOrderable string

const (
	TensionOrderableCreatedAt  TensionOrderable = "createdAt"
	TensionOrderableUpdatedAt  TensionOrderable = "updatedAt"
	TensionOrderableMessage    TensionOrderable = "message"
	TensionOrderableEmitterid  TensionOrderable = "emitterid"
	TensionOrderableReceiverid TensionOrderable = "receiverid"
	TensionOrderableNth        TensionOrderable = "nth"
	TensionOrderableTitle      TensionOrderable = "title"
	TensionOrderableNComments  TensionOrderable = "n_comments"
	TensionOrderableNBlobs     TensionOrderable = "n_blobs"
)

var AllTensionOrderable = []TensionOrderable{
	TensionOrderableCreatedAt,
	TensionOrderableUpdatedAt,
	TensionOrderableMessage,
	TensionOrderableEmitterid,
	TensionOrderableReceiverid,
	TensionOrderableNth,
	TensionOrderableTitle,
	TensionOrderableNComments,
	TensionOrderableNBlobs,
}

func (e TensionOrderable) IsValid() bool {
	switch e {
	case TensionOrderableCreatedAt, TensionOrderableUpdatedAt, TensionOrderableMessage, TensionOrderableEmitterid, TensionOrderableReceiverid, TensionOrderableNth, TensionOrderableTitle, TensionOrderableNComments, TensionOrderableNBlobs:
		return true
	}
	return false
}

func (e TensionOrderable) String() string {
	return string(e)
}

func (e *TensionOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TensionOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TensionOrderable", str)
	}
	return nil
}

func (e TensionOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TensionStatus string

const (
	TensionStatusOpen   TensionStatus = "Open"
	TensionStatusClosed TensionStatus = "Closed"
)

var AllTensionStatus = []TensionStatus{
	TensionStatusOpen,
	TensionStatusClosed,
}

func (e TensionStatus) IsValid() bool {
	switch e {
	case TensionStatusOpen, TensionStatusClosed:
		return true
	}
	return false
}

func (e TensionStatus) String() string {
	return string(e)
}

func (e *TensionStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TensionStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TensionStatus", str)
	}
	return nil
}

func (e TensionStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TensionType string

const (
	TensionTypeOperational TensionType = "Operational"
	TensionTypeGovernance  TensionType = "Governance"
	TensionTypeHelp        TensionType = "Help"
)

var AllTensionType = []TensionType{
	TensionTypeOperational,
	TensionTypeGovernance,
	TensionTypeHelp,
}

func (e TensionType) IsValid() bool {
	switch e {
	case TensionTypeOperational, TensionTypeGovernance, TensionTypeHelp:
		return true
	}
	return false
}

func (e TensionType) String() string {
	return string(e)
}

func (e *TensionType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TensionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TensionType", str)
	}
	return nil
}

func (e TensionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UserHasFilter string

const (
	UserHasFilterCreatedAt        UserHasFilter = "createdAt"
	UserHasFilterLastAck          UserHasFilter = "lastAck"
	UserHasFilterUsername         UserHasFilter = "username"
	UserHasFilterName             UserHasFilter = "name"
	UserHasFilterPassword         UserHasFilter = "password"
	UserHasFilterEmail            UserHasFilter = "email"
	UserHasFilterEmailHash        UserHasFilter = "emailHash"
	UserHasFilterEmailValidated   UserHasFilter = "emailValidated"
	UserHasFilterRights           UserHasFilter = "rights"
	UserHasFilterRoles            UserHasFilter = "roles"
	UserHasFilterBackedRoles      UserHasFilter = "backed_roles"
	UserHasFilterTensionsCreated  UserHasFilter = "tensions_created"
	UserHasFilterTensionsAssigned UserHasFilter = "tensions_assigned"
	UserHasFilterContracts        UserHasFilter = "contracts"
	UserHasFilterBio              UserHasFilter = "bio"
	UserHasFilterUtc              UserHasFilter = "utc"
)

var AllUserHasFilter = []UserHasFilter{
	UserHasFilterCreatedAt,
	UserHasFilterLastAck,
	UserHasFilterUsername,
	UserHasFilterName,
	UserHasFilterPassword,
	UserHasFilterEmail,
	UserHasFilterEmailHash,
	UserHasFilterEmailValidated,
	UserHasFilterRights,
	UserHasFilterRoles,
	UserHasFilterBackedRoles,
	UserHasFilterTensionsCreated,
	UserHasFilterTensionsAssigned,
	UserHasFilterContracts,
	UserHasFilterBio,
	UserHasFilterUtc,
}

func (e UserHasFilter) IsValid() bool {
	switch e {
	case UserHasFilterCreatedAt, UserHasFilterLastAck, UserHasFilterUsername, UserHasFilterName, UserHasFilterPassword, UserHasFilterEmail, UserHasFilterEmailHash, UserHasFilterEmailValidated, UserHasFilterRights, UserHasFilterRoles, UserHasFilterBackedRoles, UserHasFilterTensionsCreated, UserHasFilterTensionsAssigned, UserHasFilterContracts, UserHasFilterBio, UserHasFilterUtc:
		return true
	}
	return false
}

func (e UserHasFilter) String() string {
	return string(e)
}

func (e *UserHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserHasFilter", str)
	}
	return nil
}

func (e UserHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UserOrderable string

const (
	UserOrderableCreatedAt UserOrderable = "createdAt"
	UserOrderableLastAck   UserOrderable = "lastAck"
	UserOrderableUsername  UserOrderable = "username"
	UserOrderableName      UserOrderable = "name"
	UserOrderablePassword  UserOrderable = "password"
	UserOrderableEmail     UserOrderable = "email"
	UserOrderableEmailHash UserOrderable = "emailHash"
	UserOrderableBio       UserOrderable = "bio"
	UserOrderableUtc       UserOrderable = "utc"
)

var AllUserOrderable = []UserOrderable{
	UserOrderableCreatedAt,
	UserOrderableLastAck,
	UserOrderableUsername,
	UserOrderableName,
	UserOrderablePassword,
	UserOrderableEmail,
	UserOrderableEmailHash,
	UserOrderableBio,
	UserOrderableUtc,
}

func (e UserOrderable) IsValid() bool {
	switch e {
	case UserOrderableCreatedAt, UserOrderableLastAck, UserOrderableUsername, UserOrderableName, UserOrderablePassword, UserOrderableEmail, UserOrderableEmailHash, UserOrderableBio, UserOrderableUtc:
		return true
	}
	return false
}

func (e UserOrderable) String() string {
	return string(e)
}

func (e *UserOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserOrderable", str)
	}
	return nil
}

func (e UserOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UserRightsHasFilter string

const (
	UserRightsHasFilterCanLogin      UserRightsHasFilter = "canLogin"
	UserRightsHasFilterCanCreateRoot UserRightsHasFilter = "canCreateRoot"
	UserRightsHasFilterMaxPublicOrga UserRightsHasFilter = "maxPublicOrga"
	UserRightsHasFilterType          UserRightsHasFilter = "type_"
)

var AllUserRightsHasFilter = []UserRightsHasFilter{
	UserRightsHasFilterCanLogin,
	UserRightsHasFilterCanCreateRoot,
	UserRightsHasFilterMaxPublicOrga,
	UserRightsHasFilterType,
}

func (e UserRightsHasFilter) IsValid() bool {
	switch e {
	case UserRightsHasFilterCanLogin, UserRightsHasFilterCanCreateRoot, UserRightsHasFilterMaxPublicOrga, UserRightsHasFilterType:
		return true
	}
	return false
}

func (e UserRightsHasFilter) String() string {
	return string(e)
}

func (e *UserRightsHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserRightsHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserRightsHasFilter", str)
	}
	return nil
}

func (e UserRightsHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UserRightsOrderable string

const (
	UserRightsOrderableMaxPublicOrga UserRightsOrderable = "maxPublicOrga"
)

var AllUserRightsOrderable = []UserRightsOrderable{
	UserRightsOrderableMaxPublicOrga,
}

func (e UserRightsOrderable) IsValid() bool {
	switch e {
	case UserRightsOrderableMaxPublicOrga:
		return true
	}
	return false
}

func (e UserRightsOrderable) String() string {
	return string(e)
}

func (e *UserRightsOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserRightsOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserRightsOrderable", str)
	}
	return nil
}

func (e UserRightsOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UserType string

const (
	UserTypeRegular UserType = "Regular"
	UserTypeRoot    UserType = "Root"
)

var AllUserType = []UserType{
	UserTypeRegular,
	UserTypeRoot,
}

func (e UserType) IsValid() bool {
	switch e {
	case UserTypeRegular, UserTypeRoot:
		return true
	}
	return false
}

func (e UserType) String() string {
	return string(e)
}

func (e *UserType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserType", str)
	}
	return nil
}

func (e UserType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type VoteHasFilter string

const (
	VoteHasFilterContract VoteHasFilter = "contract"
	VoteHasFilterNode     VoteHasFilter = "node"
	VoteHasFilterData     VoteHasFilter = "data"
)

var AllVoteHasFilter = []VoteHasFilter{
	VoteHasFilterContract,
	VoteHasFilterNode,
	VoteHasFilterData,
}

func (e VoteHasFilter) IsValid() bool {
	switch e {
	case VoteHasFilterContract, VoteHasFilterNode, VoteHasFilterData:
		return true
	}
	return false
}

func (e VoteHasFilter) String() string {
	return string(e)
}

func (e *VoteHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VoteHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VoteHasFilter", str)
	}
	return nil
}

func (e VoteHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
